Bitcask 本质上是一种**底层存储引擎的设计模式**，而非一个 "开箱即用" 的完整服务
它的核心聚焦于 "数据如何在磁盘和内存中高效组织"
而网络交互、后台任务（如合并）等 “服务级特性” 需要依赖上层系统来补充




![[Pasted image 20250523214346.png]]

一个 bitcask 实例就是系统上的一个目录
限制同一时刻只能有一个进程打开这个目录
目录中有多个文件，==同一时刻只有一个**活跃的文件**用于写入==
当活跃文件写到满足一个阈值之后，就会被关闭，成为旧的数据文件，并且打开一个新的文件用于写入
目录：一个活跃文件和多个旧的数据文件的集合

![[Pasted image 20250523214930.png]]
当前活跃文件是追加写（append only），这意味着可以利用顺序IO，不会有多余的磁盘寻址，最大限度保证了吞吐

# row
写入到文件的数据，具有固定的格式，大致有这些字段：
- `crc`：数据校验，防止数据被破坏、篡改等
- `timestamp`：写入数据的时间戳
- `ksz`：key size，key 的大小
- `value_sz`：value size，value 的大小
- `key`：用户实际存储的 key
- `value`：用户实际存储的 value

每次写入都是追加写到活跃文件当中
删除操作实际上也是一次追加写入，只不过写入的是一个特殊的墓碑值（tombstone value），用于标记一条记录的删除，也就是说不会实际去删除某条数据
在下次`merge`时，才会将无效的数据清除


![[Pasted image 20250523215341.png]]

所以一个文件的数据，实际上是多个相同格式的数据集合的排列：
![[Pasted image 20250523215756.png]]

---
# keydir
在追加写入磁盘文件完成后，然后更新内存中的数据结构`keydir`，就是全部`key`的一个集合，存储的是`key`到一条磁盘文件数据的位置
我们需要一种支持高效插入、读取、删除数据的结构，并且如果需要数据高效遍历的话，我们最好选择天然支持有序的一种结构
常见的选择有：BTree、跳表、红黑树等

![[Pasted image 20250524095549.png]]

`keydir` 一定会存储一条数据在磁盘中最新的位置，旧的数据仍然存在，等待 `merge` 的时候被清理
因此，读取数据流程：
1. 根据`key`从内存中找到对应的记录，记录存储的是数据在磁盘中的位置
2. 根据位置找到磁盘中对应的数据文件

![[Pasted image 20250524113153.png]]


---
# hint
由于旧的数据实际上一直存在于磁盘中，我们并没有将旧的数据删除，而是新追加一条标识其被删除的记录，通过`merge`的过程来清除所有无效的数据
`merge` 会遍历所有不可变的旧数据文件，将所有有效的数据重新写到新的数据文件中，并且将旧的数据文件删除掉

![[Pasted image 20250717195604.png]]


`merge` 完成后，还会为每个数据文件生成一个`hint`文件，`hint`文件可以看作是全部数据的索引，它和数据文件唯一的区别是，它不会存储实际的 `value`
==**`hint` 文件作用**：在 `bitcask` 启动的时候，直接加载 `hint` 文件中的数据，快速构建索引，而不用去全部重新加载数据文件==

