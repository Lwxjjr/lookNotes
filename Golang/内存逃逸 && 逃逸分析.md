# 栈/堆

- 栈分配是在函数调用时为局部变量分配内存，当函数返回时，这些内存会自动释放
- 堆分配则是通过 new 或者 make 函数动态分配内存，需要手动进行释放

# 什么是内存逃逸？

==内存逃逸是指原本应该在栈上分配的内存被分配到了堆上==。这意味着即使函数返回后，这部分内存也不会被自动释放，需要等待垃圾回收器GC来回收  
==在栈上分配和回收内存的开销很低，只需要 2 个 CPU 指令：PUSH 和 POP==，一个是将数据 push 到栈空间以完成分配，pop 则是释放空间，也就是说在栈上分配内存，消耗的仅是将数据拷贝到内存的时间，而内存的 I/O 通常能够达到 30GB/s，因此在栈上分配内存效率是非常高的  
在堆上分配内存，一个很大的额外开销则是垃圾回收。Go 语言使用的是标记清除算法，并且在此基础上使用了三色标记法和写屏障技术，提高了效率  

## GC的机制
[[内存分配 && 垃圾回收]]  

## 内存逃逸的影响

如果频繁发生内存逃逸，会导致程序占用过多的内存资源，影响程序的性能和稳定性
1. ==内存占用增加==：堆分配的内存不会自动释放，所以会导致程序占用的内存资源不断增加
2. ==性能下降==：相比于栈分配，堆分配需要更多的 CPU 和内存资源
3. ==程序不稳定==：如果程序中存在大量的内存逃逸，可能会导致垃圾回收器频繁工作


# 逃逸分析
## 为什么引入逃逸分析
逃逸分析(escape analysis)：编译器决定内存分配位置的方式  
==逃逸分析由编译器完成，作用于编译阶段==  
==为了减少`GC`造成的压力==，`Go`语言引入了逃逸分析，也就是想法设法尽量减少在堆上的内存分配，可以在栈中分配的变量尽量留在栈中  
逃逸分析是在编译阶段进行的，可以通过 `go build -gflags '-m -m -l`  
- `-m -m`看到所有编译器优化
- `-l`禁用掉内联优化，只关注逃逸优化


## 内存逃逸的原因

内存逃逸的主要原因是在函数返回后，==局部变量仍然被外部引用==

### _1. 指针逃逸_
函数中创建了一个对象，返回了对象的指针，因为指针的存在，对象的内存不能随着函数结束而回收，因此只能分配在堆上
```go
func Add(x,y int) *int { 
	res := 0 
	res = x + y 
	return &res 
} 

func main() {
	Add(1,2)
}
```

查看逃逸分析结果：
```go
go build -gcflags="-m -m -l" ./test1.go
# command-line-arguments
./test1.go:6:9: &res escapes to heap
./test1.go:6:9:         from ~r2 (return) at ./test1.go:6:2
./test1.go:4:2: moved to heap: res
```


### _2. interface{}动态类型逃逸_
空接口即 `interface{}` 可以表示任意的类型，函数参数为 `interface{}`，==编译期间很难确定其参数的具体类型，也会发生逃逸==
```go
func main()  {
	str := "hello"
	fmt.Printf("%v",str)
}
```
查看逃逸分析结果：
```go
go build -gcflags="-m -m -l" ./test2.go 
# command-line-arguments
./test2.go:9:13: str escapes to heap
./test2.go:9:13:        from ... argument (arg to ...) at ./test2.go:9:13
./test2.go:9:13:        from *(... argument) (indirection) at ./test2.go:9:13
./test2.go:9:13:        from ... argument (passed to call[argument content escapes]) at ./test2.go:9:13
./test2.go:9:13: main ... argument does not escape

```
`fmt.Println()`函数的入参是一个`interface{}`类型

### _3. 闭包逃逸_
> [!闭包] 
> 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说==函数被引用包围==），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。

```go
func Increase() func() int {  
	n := 0  
	return func() int {  
		n++  
		return n  
	}  
}  
  
func main() {  
	in := Increase()  
	fmt.Println(in()) // 1  
	fmt.Println(in()) // 2  
}
```
查看逃逸分析结果：
```go
go build -gcflags=-m main_closure.go   
# command-line-arguments  
./main_closure.go:6:2: moved to heap: n
```

### _4. 变量大小不确定/栈空间不足_
在Linux平台查看操作系统的栈大小：
```bash
$ ulimit -a
-s: stack size (kbytes)    8192
-n: file descriptors       12800
...
```

```go
func generate8191() {  
	nums := make([]int, 8191) // < 64KB  
	for i := 0; i < 8191; i++ {  
		nums[i] = rand.Int()  
	}  
}  
  
func generate8192() {  
	nums := make([]int, 8192) // = 64KB  
	for i := 0; i < 8192; i++ {  
		nums[i] = rand.Int()  
	}  
}  
  
func generate(n int) {  
	nums := make([]int, n) // 不确定大小  
	for i := 0; i < n; i++ {  
		nums[i] = rand.Int()  
	}  
}  
  
func main() {  
	generate8191()  
    generate8192()  
    generate(1)  
}
```
查看逃逸分析结果：
```go
$ go build -gcflags=-m main_stack.go  
# command-line-arguments  
./main_stack.go:9:14: generate8191 make([]int, 8191) does not escape  
./main_stack.go:16:14: make([]int, 8192) escapes to heap  
./main_stack.go:23:14: make([]int, n) escapes to heap
```

`make([]int, 8191)` 没有发生逃逸，`make([]int, 8192)` 和`make([]int, n)` 逃逸到堆上，也就是说，==当切片占用内存超过一定大小，或无法确定当前切片长度时，对象占用内存将在堆上分配==

## 如何利用逃逸分析提升性能
### 传值 VS 传指针

传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能

---
## Channel 分配在栈上还是堆上
Channel 被设计用来实现协程间通信的组件，其作用域和生命周期不可能仅限于某个函数内部，所以 golang 直接将其分配在堆上