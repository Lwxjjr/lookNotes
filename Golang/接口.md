C++ 定义接口的方式称为"侵入式"
而 Go 采用的是"非侵入式"，不需要显式声明，只需 要实现接口定义的函数，编译器就会自动识别
C++和Go在定义接口方式的不同，也导致了其在底层实现上的不同
- C++ 通过虚函数表来实现基类调用派生类的函数
- Go通过`itab`中的`fun`字段来实现接口变量调用实体类型的函数
- C++ 中的虚函数表是在编译期生成的
- Go 的 itab 中的 fun 字段是在运行期间动态生成的（原因是实体类型可能会无意中实现N个接口）

==接口变量可以存储任何实现了接口定义的所有方法的变量==
# iface/eface
类型iface、eface都是Go中描述接口的底层结构体
- iface：描述的接口包含方法
- eface：不包含方法的空接口（interface{}）

```go
// src/runtime/runtime2.go
type iface struct { 
    tab  *itab 
    data unsafe.Pointer 
} 
type itab struct { 
    inter  *interfacetype 
    _type  *_type 
    link   *itab 
	hash   uint32 // copy of _type.hash. Used for type switches. 
    _      [4]byte 
    fun    [1]uintptr // variable sized 
} 
type eface struct { 
    _type  *_type 
    data   unsafe.Pointer 
} 
```
`iface`：
- `tab`：指向一个`itab`实体，表示接口类型以及赋予给这个接口的实体类型
- `data`：指向接口具体的值，一般是一个指向堆内存的指针

`itab`：
- `_type`：实体的类型，包括内存对齐方式、大小等
- `inter`：接口的类型
- `fun`：段放置和接口方法对应的具体数据类型的方法地址

```go
// src/runtime/type.go 
 
type _type struct { 
    size       uintptr     // 类型大小 
    ptrdata    uintptr 
    hash       uint32     // 类型的 hash 值 
    tflag      tflag     // 类型的 flag，和反射相关 
    align      uint8     // 内存对齐相关 
    fieldalign uint8 
    kind       uint8     // 类型的编号，有bool, slice, struct 等 
    equal func(unsafe.Pointer, unsafe.Pointer) bool 
    gcdata    *byte     // GC 相关 
    str       nameOff 
    ptrToThis typeOff 
} 
```

Go中各种类型都是在`_type`字段的基础上，增加一些额外字段来进行管理的，这些数据类型的结构体定义，是反射实现的基础
```go
// src/reflect/type.go 
 
type arraytype struct { 
    typ   _type 
    elem  *_type 
    slice *_type 
    len   uintptr 
} 
 
type chantype struct { 
    typ  _type 
    elem *_type 
    dir  uintptr 
} 
 
type slicetype struct { 
    typ  _type 
    elem *_type 
} 
 
type structtype struct { 
    typ     _type 
    pkgPath name 
    fields  []structfield 
} 
```


![[Pasted image 20250427162038.png|575]]

# 方法
方法能给用户==自定义的类型添加新的行为==
它和函数的区别在于方法有一个接收者（可以是值接收/指针接收）
不管方法的接收者是什么类型，该类型的值和指针都可以调用

|        | 值接收者                               | 指针接收者                                     |
| ------ | ---------------------------------- | ----------------------------------------- |
| 值类型调用  | 方法会使用调用者的一个副本，类似于"传值"              | 使用值的引用调用方法，如user.Info() => (&user).Info() |
| 指针类型调用 | 指针被杰引用为值，user.Info => (*user).Info | 传值，复制了一份指针                                |
实现了接收者是值类型的方法，相当于==自动实现了接收者是指针类型的方法==
实现了接收者是指针类型的方法，不会==自动生成对应接收者是值类型的方法==
也就是：
如果实现了接收者是值类型的方法，会==隐含==地也实现了接收者是指针类型的方法

## 两者使用情况
1. 接收者：值类型，修改的都是对象的副本，不影响调用者
2. 接收者：指针类型，调用者修改的是指针指向的对象本身

使用指针作为方法的接收者的理由如下：
1. 方法能够修改接收者指向的值
2. 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效


---
# 接口的动态类型/动态值
`iface`两个字段：
1. `tab`：接口表指针，指向类型信息（动态类型）
2. `data`：数据指针，指向具体数据（动态值）

接口值 == `nil` 需要动态类型和动态值都为 `nil`


---
# 类型转换/断言
Go不允许隐式类型转换，`=`两侧不允许出现类型不同的变量
类型转换、类型断言本质都是把==一个类型转换成另外一个类型==
不同的是：类型断言是对==接口变量进行的操作==
因为空接口 interface{} 没有定义任何函数，因此 ==Go 中所有类型都实现了空接口==
当一个函 数的形参是 interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型
断言语法：
```bash
<目标类型的值>，<布尔参数> := <表达式>.(目标类型)     // 安全类型断言 
<目标类型的值> := <表达式>.(目标类型)                //非安全类型断言 
```
