# 内存分配
C是通过`malloc`动态申请内存
内存分配器使用的是`glibc`提供的`ptmalloc2`
除了`glibc`，业内出名的内存分配器有`Google`的`tcmalloc`和`Facebook`的`jemalloc`
`Golang`中也实现了内存分配器，原理与`tcmalloc`类似
简单来说：维护一块大的全局内存，每个线程(Golang中为P)维护一块小的私有内存，私有内存不足再从全局申请

---
# 基础概念
为了方便自主管理内存，做法便是先向系统==申请一块内存，然后将内存切割成小块，通过一定的内存分配算法管理内存==
以64bit系统为例，`Go`程序启动时会向系统申请的内存如下图：
![[Pasted image 20250504201241.png|475]]
预申请的内存划分为`spans、bitmap、arena`三部分
`arena`即为所谓的堆区，应用中需要的内存从这里分配
`spans`和`bitmap`是为了管理arena区而存在的

`arena`的大小为`512G`，`page`大小为`8KB`，一共有`512GB/8KB`个页
`spans`区域存放`span`指针，==每个指针对应一个或者多个`page`==
`spans`区域的大小为`(512GB/8KB)*指针大小8byte = 512M`
> [!tip] `GOEXPERIMENT=arenas`使用特性

## span
`span`是用于管理`arena`页的关键数据结构，每个`span`中包含1个或多个连续页
为了满足小对象分配，span中的一页会划分更小的粒度，而对于大对象比如超过页大小，则通过多页实现
### class
根据对象大小，划分了一系列`class`，每个`class`都代表一个固定大小的对象，以及每个`span`的大小
- `class`： class ID，每个span结构中都有一个class ID, 表示该span可处理的对象类型
- `bytes/obj`：该class代表对象的字节数
- `bytes/span`：每个span占用堆的字节数，也即页数*页大小
- `objects`: 每个span可分配的对象个数，也即（bytes/spans）/（bytes/obj）
- `waste bytes`: 每个span产生的内存碎片，也即（bytes/spans）%（bytes/obj）
```go
// class  bytes/obj  bytes/span  objects  waste bytes
//     1          8        8192     1024            0
//     2         16        8192      512            0
//     3         32        8192      256            0
//     4         48        8192      170           32
//     5         64        8192      128            0
//     6         80        8192      102           32
//     7         96        8192       85           32
//     8        112        8192       73           16
//     9        128        8192       64            0
//    10        144        8192       56          128
//    11        160        8192       51           32
//    12        176        8192       46           96
//    13        192        8192       42          128
//    14        208        8192       39           80
//    15        224        8192       36          128
//    16        240        8192       34           32
//    17        256        8192       32            0
//    18        288        8192       28          128
//    19        320        8192       25          192
//    20        352        8192       23           96
//    21        384        8192       21          128
//    22        416        8192       19          288
//    23        448        8192       18          128
//    24        480        8192       17           32
//    25        512        8192       16            0
//    26        576        8192       14          128
//    27        640        8192       12          512
//    28        704        8192       11          448
//    29        768        8192       10          512
//    30        896        8192        9          128
//    31       1024        8192        8            0
//    32       1152        8192        7          128
//    33       1280        8192        6          512
//    34       1408       16384       11          896
//    35       1536        8192        5          512
//    36       1792       16384        9          256
//    37       2048        8192        4            0
//    38       2304       16384        7          256
//    39       2688        8192        3          128
//    40       3072       24576        8            0
//    41       3200       16384        5          384
//    42       3456       24576        7          384
//    43       4096        8192        2            0
//    44       4864       24576        5          256
//    45       5376       16384        3          256
//    46       6144       24576        4            0
//    47       6528       32768        5          128
//    48       6784       40960        6          256
//    49       6912       49152        7          768
//    50       8192        8192        1            0
//    51       9472       57344        6          512
//    52       9728       49152        5          512
//    53      10240       40960        4            0
//    54      10880       32768        3          128
//    55      12288       24576        2            0
//    56      13568       40960        3          256
//    57      14336       57344        4            0
//    58      16384       16384        1            0
//    59      18432       73728        4            0
//    60      19072       57344        3          128
//    61      20480       40960        2            0
//    62      21760       65536        3          256
//    63      24576       24576        1            0
//    64      27264       81920        3          128
//    65      28672       57344        2            0
//    66      32768       32768        1            0
```



---
# 内存垃圾的产生

![[Pasted image 20250323225356.png]]
# 为什么需要GC
手动管理内存挺麻烦，管错或者管漏内存也很糟糕，将会直接导致程序不稳定（持续泄露）甚至直接崩溃  

## GC触发场景
1. `gcTriggerHeap`：==到达阈值==（控制器计算的触发堆大小）
	- 阀值 = 上次GC内存分配量 * 内存增长率
	- 内存增长率由`GOGC`控制，默认为`100`，即每当内存扩大一倍时启动`GC`
2. `gcTriggerTime`：==GC触发时间周期，默认2分钟==
	- 在`src/runtime/proc.go:forcegcperiod`变量中被声明：
	- `var forcegcperiod int64 = 2 * 60 * 1e9`
3. `runtime.GC`：手动触发（需要手动强制触发的场景极其少见，可能会是在某些业务方法执行完后，==因其占用了过多的内存，需要人为释放。又或是 debug 程序所需==)

## GC在哪里触发
### 监控线程
实质上在 Go ==运行时（runtime）初始化时，会启动一个 goroutine，用于处理 GC 机制==的相关事项  

需要特别关注的是在 `forcegchelper` 方法中，会调用 `goparkunlock` 方法让该 goroutine 陷入休眠等待状态，以==减少不必要的资源开销==

```go
func init() {  
    go forcegchelper()  
}  
  
func forcegchelper() {  
    forcegc.g = getg()  
    lockInit(&forcegc.lock, lockRankForcegc)  
    for {  
       lock(&forcegc.lock)  
       if forcegc.idle != 0 {  
          throw("forcegc: phase error")  
       }  
       atomic.Store(&forcegc.idle, 1)  
       goparkunlock(&forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, 1)  
       // this goroutine is explicitly resumed by sysmon  
       if debug.gctrace > 0 {  
          println("GC forced")  
       }  
  
       gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})  
    }  
}
```

在休眠后，会由 `sysmon` 这一个系统监控线程来进行监控、唤醒等行为：
这段代码核心的行为就是不断地在 for 循环中，对 `gcTriggerTime` 和 `now` 变量进行比较，==判断是否达到一定的时间（默认为 2 分钟）==  
若达到意味着满足条件，会将 `forcegc.g` 放到全局队列中接受新的一轮调度，再进行对上面 `forcegchelper` 的唤醒

```go
func sysmon() {
 ...
 for {
  ...
  // check if we need to force a GC
  if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() && atomic.Load(&forcegc.idle) != 0 {
   lock(&forcegc.lock)
   forcegc.idle = 0
   var list gList
   list.push(forcegc.g)
   injectglist(&list)
   unlock(&forcegc.lock)
  }
  if debug.schedtrace > 0 && lasttrace+int64(debug.schedtrace)*1000000 <= now {
   lasttrace = now
   schedtrace(debug.scheddetail > 0)
  }
  unlock(&sched.sysmonlock)
 }
}
```

### 堆内存申请
- 小对象：如果申请小对象时，发现当前内存空间不存在空闲跨度时，将会需要调用 `nextFree` 方法获取新的可用的对象，可能会触发 GC 行为。
- 大对象：如果申请大于 32k 以上的大对象时，可能会触发 GC 行为
```go
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {  
    shouldhelpgc := false  
    ...  
    if size <= maxSmallSize {  
       if noscan && size < maxTinySize {  
          ...  
          // Allocate a new maxTinySize block.  
          span = c.alloc[tinySpanClass]  
          v := nextFreeFast(span)  
          if v == 0 {  
             v, span, shouldhelpgc = c.nextFree(tinySpanClass)  
          }  
          ...  
          spc := makeSpanClass(sizeclass, noscan)  
          span = c.alloc[spc]  
          v := nextFreeFast(span)  
          if v == 0 {  
             v, span, shouldhelpgc = c.nextFree(spc)  
          }  
          ...  
       }  
    } else {  
       shouldhelpgc = true  
       span = c.allocLarge(size, needzero, noscan)  
       ...  
    }  
  
    if shouldhelpgc {  
       if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {  
          gcStart(t)  
       }  
    }  
  
    return x  
}
```


---
# 垃圾回收算法
业界常见的垃圾回收算法：
- **引用计数**：==对每个对象维护一个引用计数==，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为 0 时回收该对象
	- 优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阀值时才回收。
	- 缺点：不能很好地处理循环引用，而且实时维护引用计数，也有一定的代价。
	- 代表语言：Python、PHP、Swift
- **标记-清扫**：从==根变量开始遍历所有引用的对象，引用的对象标记为”被引用”==，没有被标记的进行回收
	- 优点：解决了引用计数的缺点。
	- 缺点：需要STW，即要暂时停掉程序运行。
	- 代表语言：Golang（其采用三色标记法）
- **分代回收**：==按照对象生命周期长短划分不同的代空间==，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率
	- 优点：回收性能好
	- 缺点：算法复杂
	- 代表语言：JAVA
---
# GC机制变革
垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源  
GolangGC的变革：
1. GO V1.3之前的标记-清除（mark and sweep）算法
2. Go V1.5的三色标记法
3. Go V1.8混合写屏障机制

## Go V1.3之前的标记-清除（mark and sweep）算法

mark and sweep主要有2个阶段：
- 标记(Mark phase)  
- 清除(Sweep phase)

通过STW暂停程序业务逻辑，分类可达和不可达对象，做上标记  
STW的过程中，CPU不执行用户代码，全部用于垃圾回收

### mark and sweep的缺点
1. STW：让程序暂停，程序出现卡顿（==重要问题==）
2. 标记需要扫描整个heap
3. 清除数据会产生heap碎片


## Go V1.5的三色并发标记法

GC过程和其他用户goroutine可并发运行，但需要一定时间的**STW(stop the world)**
1. 白色对象：表示对象尚未被访问
2. 灰色对象：表示对象本身已被访问，但其引用的其他对象尚未全部访问
3. 黑色对象：表示对象及其所有引用的对象都已被访问

三色标记法步骤：
1. 将所有对象标记为白色
2. 从根节点集合出发，将第一次遍历到的节点标记为灰色放入集合列表中
3. 遍历灰色集合，将灰色节点遍历到的白色节点标记为灰色，并把灰色节点标记为黑色
4. 循环这个过程
5. 直到灰色节点集合为空，回收所有的白色节点

### 没有STW的三色标记法

如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性  
有两种情况，在三色标记法中，是不希望被发生的：
1. ==白色对象被黑色对象引用==
2. ==灰色对象与它之间的可达关系的白色对象遭到破坏== 

如果当以上两个条件同时满足时，就会出现对象丢失现象  
为了防止这种现象的发生，最简单的方式就是STW，但是STW有明显的资源浪费  


## 屏障机制

- STW目的是防止GC扫描时内存变化而停掉goroutine
- 写屏障就是让goroutine与GC同时运行的手段

在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？  
我们让GC回收器，满足下面两种情况之一时，即可保对象不丢失。
1. 强三色不变式
2. 弱三色不变式

为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”

![[Pasted image 20250326232832.png|500]]
![[Pasted image 20250326233028.png|625]]


---
### 插入屏障

==在A对象引用B对象的时候，B对象被标记为灰色==  

> [!Warning]
栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用
所以“插入屏障”机制,在栈空间的对象操作中不使用 ==而仅仅使用在堆空间对象的操作中==.  

但是三色标记法扫描之后，栈上可能依然存在白色对象被引用的情况，为了对象不丢失, 
在准备回收白色前，要对本次标记扫描启动STW暂停，重新遍历一次栈空间三色扫描

---
### 删除屏障

==被删除的对象，如果自身为灰色或者白色，那么被标记为灰色==

这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉

> [!解读：]
> 1. **分代收集机制**：现代垃圾回收器通常采用分代收集，将内存分为年轻代和老年代。年轻代的GC频率较高，而老年代的GC较少。因此，一个对象可能被保留在年轻代中，直到下一次年轻代的GC才会被回收
> 2. **GC触发条件**：垃圾回收并不是每次删除指针后立即触发，而是等到内存达到一定阈值或特定时间点才会启动。因此，对象可能在下一次GC时才被处理


---

## Go V1.8的混合写屏障(hybrid write barrier)机制

插入写屏障和删除写屏障的短板：
- 插入写屏障：==结束时需要STW来重新扫描栈==，标记栈上引用的白色对象的存活；
- 删除写屏障：==回收精度低==，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。  

Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点  

操作流程：
1. GC开始将==栈上的可达对象全部扫描并标记为黑色==(之后不再进行第二次重复扫描，无需STW)
2. GC期间，任何在栈上创建的新对象，均为黑色
3. 堆上被删除的对象标记为灰色
4. 堆上被添加的对象标记为灰色


---
