# 环境变量
Go的包管理涉及一些环境变量
- GOROOT：go语言目录的根目录，包括编译器、命令行等工具
- GOBIN：go生成的可执行文件存储位置
- GOPATH：工作区目录路径，用于存放源代码文件、归档文件以及可执行文件
- GOPROXY：用于指定下载第三方依赖包的代理服务器地址
- GO111MODULE：控制是否启用Go Modules，即新的依赖管理机制
- GOMODCACHE：定义了Go Modules下载的依赖包存储的位置，默认是$GOPATH/pkg/mod
# GOROOT
通常我们说安装Go语言，实际上安装的是Go编译器和Go标准库，二者位于同一个安装包中
==GOROOT实际上是指示GO语言安装目录的环境变量，属于GO语言顶级目录==

---
# GOPATH
GO语言是由一个或者多个`package`组成的
`package`按来源分类：
- 标准库（位于`GOROOT`环境变量指示的目录中）
- 第三方库（位于`GOPATH`环境变量指示的目录中）
- 项目私有库（位于`GOPATH`环境变量指示的目录中）

**GOPATH开发模式也是早期Go语言采用的默认方式**
项目必须位于`$GOPATH/src`目录内，而且所有的依赖包也都集中存储在此处
一个`GOPATH`可以包含一个或多个工作区，每个工作区包含`src`、`pkg`、`bin`
- `src`：存放源代码
- `pkg`：存放`go install`生成的`.a`归档文件
- `bin`：存放编译后的可执行文件

这种模式简单，但是随着项目的复杂度增加，尤其处理多个版本及其依赖的不同版本具有局限性：==多项目无法共享同一个GOPATH==
> [!example]
> GO程序`App1`、`App2`都需要使用第三方库`LibX`的不同版本
> `App1`依赖于`LibX v1.0`，`App2`需要使用`LibX v2.0`的新特性
> 在`GOPATH`模式下，所有依赖都放置在一个共享的位置，不能够同时安装`LibX`的两个版本，因此至少一个应用无法按照预期运行

如果一个项目对应一个工作区，理论上可以减少一些在依赖管理和版本控制方面的问题
## GOPATH存在的问题
1. ==为每个项目维护独立的工作区的`GOPATH`会导致重复存储依赖包，增加磁盘空间的使用==
2. 手动切换`GOPATH`管理多个环境变量，既繁琐又容易出错

---
# VENDER
vender机制也没有解决：多项目无法共享一个`GOPATH`
但是它提供了一个机制让项目的依赖隔离而不相互干扰
`GO 1.6`，`vender`机制正式启用，允许把项目的依赖全部放在一个位于本项目的`vender`目录
==`vender`目录简单理解：私有的`GOPATH`目录==
编译时，优先从`vender`中寻找依赖包，再从`GOPATH`中寻找

如有一个`github.com/constabulary/example-gsftp`项目，项目目录结构如下：
```c
$GOPATH
|    src/
|    |    github.com/constabulary/example-gsftp/
|    |    |    cmd/
|    |    |    |    gsftp/
|    |    |    |    |    main.go
```
其中 `main.go`中依赖如下几个包：
```go
import (
    "golang.org/x/crypto/ssh"
    "github.com/pkg/sftp"
)
```

没有使用vendor目录时，若想编译这个项目，那么GOPATH目录结构应该是如下所示：
所有依赖的包，都位于`$GOPATH/src`下
```c
$GOPATH
|    src/
|    |    github.com/constabulary/example-gsftp/
|    |    golang.org/x/crypto/ssh
|    |    github.com/pkg/sftp
```

使用`vender`把2个依赖包版本固化下来
```c
$GOPATH
|    src/
|    |    github.com/constabulary/example-gsftp/
|    |    |    cmd/
|    |    |    |    gsftp/
|    |    |    |    |    main.go
|    |    |    vendor/
|    |    |    |    github.com/pkg/sftp/
|    |    |    |    golang.org/x/crypto/ssh/
```

## vendor存在的问题
`vender`很好的解决了多项目间的隔离问题
1. 但是位于`vender`中的依赖包==无法指定版本==，在把依赖包放入`vender`的那刻起，它就固定在当时的版本，项目使用者==很难识别你所使用的依赖版本==
2. ==二进制急剧扩大问题==，如果vendor目录过于分散，很可能会出现同一个依赖包，在项目的多个vendor中出现多次，这样依赖包会多次编译进二进制文件（如依赖于`A`/`B`开源包，`A`中有一个`vender`目录，其中也放了`B`，项目中存在2个`B`开源包，再者如果两个开源包版本不一致呢？）

---
# GOMODULE
`GO v1.11`版本引入`Module`
- `GOPATH`最大的困扰是==无法让多个项目共享同一个`package`的不同版本==
- `vender`问题是==无法很好的管理依赖的`package`==，如升级`package`

`Go Module`是一种全新的依赖管理方案
==实际上只是精准的记录项目的依赖情况，包括每个依赖的精确版本号==
主要解决两个重要的问题：
- ==准确的记录项目依赖==（`package`依赖/版本，编译你的项目都必须使用特定的版本）
- ==可重复的构建==（项目无论在什么环境构建，产物都是相同的） 

> [!官方给出module定义]
> `A module is a collection of related Go packages that are versioned together as a single unit`
> 一个`module`：一组`package`的集合，一起被标记版本

仓库、`module`、`package`关系：
- 一个仓库包含一个或多个`Go module`
- 每个`Go module`包含一个或多个`Go package`
- 每个`package`包含一个或多个Go源文件

## 语义化版本规范
版本号格式为`v<major>.<minor>.<patch>`
详细信息前往[https://semver.org/](https://semver.org/)查看
- `major`：大版本，==发生不兼容的改动==才可以增加，如`v2.x.y`和`v1.x.y`
- `minor`：小版本，==有新增特性==才可以增加，如`v1.17.0`是在`v1.16.0`基础上加了新的特性，同时兼容`v1.16.0`
- `patch`：补丁版本，==有bug修复时==才可以增加，如`v1.17.1`修复了`v1.17.0`上的bug，没有新特性增加

## 初始化module
一个项目要使用`module`，本身需要先成为一个`module`，需要一个`module`名字
==项目的`module`名字以及其依赖信息记录在`go.mod`文件中，可以手动创建，也可以使用`go mod init`命令自动生成==
`go mod init [module]`，`go mod init`会尝试从版本控制系统或import的注释中猜测一个
```bash
D:\projectTwo\test_module>go mod init test_module
go: creating new go.mod: module test_module
go: to add module requirements and sums:
        go mod tidy
```

## 管理依赖
我们准备引入一个第三方包`github.com/google/uuid`
```go
package main

import (
    "fmt"
    "github.com/google/uuid"
)

func main() {
    id := uuid.New().String()
    fmt.Println("UUID: ", id)
}
```
开始编译之前，我们通过`go get`来分析依赖情况，并会自动下载对应依赖
`go get`命令自动下载对应依赖的最新版本，并自动修改`go.mod`文件
```bash
D:\projectTwo\test_module>go get
go: added github.com/google/uuid v1.6.0
```
`go.mod`文件：
```go
module test_module  
  
go 1.24.0  
  
require github.com/google/uuid v1.6.0
```
`go.sum`文件（项目的第一次引用外部依赖）
该文件通过记录每个依赖包的hash值，来确保依赖包没有被篡改
```go
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=  
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
```
没有使用`go get`下载依赖，而是直接使用`go build main.go`允许项目的话，也会自动下载

## go.sum文件
Go引入`go.mod`文件来标记每个依赖包的版本
考虑下载的依赖包有可能被黑客恶意篡改，以及缓存在本地的依赖包也可能被篡改，单单一个`go mod`文件不能保证一致性构建
==为了解决`Go module`这一安全隐患，引入了`go sum`文件，用于记录每个依赖包的哈希值==

`go.sum`文件每行由`module`名、版本和哈希组成，并由空格分开
```go
<module> <version>[/go.mod] <hash>
```

```go
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=  
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
```
正常情况下，每个`依赖包版本`会包含两条记录:
1. `依赖包版本`整体（所有文件）的哈希值
2. `依赖包版本`中`go.mod`文件的哈希值

`go.mod`记录直接依赖的`依赖包版本`
`go.sum`记录构建用到的所有`依赖包版本`

## replace
`replace`指替换，它指示编译工具替换`require`指定中出现的包
我们在`require`中指定的依赖如下：
```go
module test_module  
  
go 1.24.0  
  
require github.com/google/uuid v1.6.0
```

我们可以使用`go list -m all`命令查看最终选定的版本
```bash
D:\projectTwo\test_module>go list -m all
test_module
github.com/google/uuid v1.6.0
```
我们修改`go.mod`，添加`replace`指令：
```bash
replace github.com/google/uuid v1.1.1 => github.com/google/uuid v1.1.0
```


## indirect
随着引入的依赖增多，有些`go.mod`文件中部分依赖包后面会出现一个`// indirect`的标识
这个标识总是出现在`required`指令中，`//`与代码的行注释一样表示注释的开始，`indirect`表示间接的依赖
如`Kubernetes（v1.17.0版本）`的 go.mod 文件中就有数十个依赖包被标记为`indirect`
```go
require (
    github.com/Rican7/retry v0.1.0 // indirect
    github.com/auth0/go-jwt-middleware v0.0.0-20170425171159-5493cabe49f7 // indirect
    github.com/boltdb/bolt v1.3.1 // indirect
    github.com/checkpoint-restore/go-criu v0.0.0-20190109184317-bdb7599cd87b // indirect
    github.com/codegangsta/negroni v1.0.0 // indirect
    ...
)
```
