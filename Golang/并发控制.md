> [!example] 场景
> 协程A执行过程中需要创建子协程A1、A2、A3...An
> 协程A创建完子协程后就等待子协程退出

针对这种场景，GO提供了三种解决方案：
- Channel: 使用channel控制子协程
- WaitGroup : 使用信号量机制控制子协程
- Context: 使用上下文控制子协程

三种方案各有优劣，比如Channel优点是实现简单，清晰易懂，WaitGroup优点是子协程个数
动态可调整，Context优点是对子协程派生出来的孙子协程的控制

---
# channel
channel一般用于协程之间的通信，channel也可以用于并发控制
如主协程启动N个子协程，主协程等待所有子协程退出后再继续后续流程

创建N个channel来管理N个协程，每个协程都有一个channel用于跟父协程通信，父协程创建完所有协程后等待所有协程结束
```go
package main

import (
    "time"
    "fmt"
)

func Process(ch chan int) {
    //Do some work...
    time.Sleep(time.Second)

    ch <- 1 //管道中写入一个元素表示当前协程已结束
}

func main() {
    channels := make([]chan int, 10) //创建一个10个元素的切片，元素类型为channel

    for i:= 0; i < 10; i++ {
        channels[i] = make(chan int) //切片中放入一个channel
        go Process(channels[i])      //启动协程，传一个管道用于通信
    }

    for i, ch := range channels {  //遍历切片，等待子协程结束
        <-ch
        fmt.Println("Routine ", i, " quit!")
    }
}
```

使用channel来控制子协程的优点是实现简单
缺点是当需要大量创建协程时就需要有相同数量的channel，而且对于子协程继续派生出来的协程不方便控制

---
# WaitGroup
WaitGroup是Golang应用开发过程中经常使用的并发控制技术
==WaitGroup，可理解为Wait-Goroutine-Group，即等待一组goroutine结束==
## 信号量
信号量是Unix系统提供的一种保护共享资源的机制，==用于防止多个线程同时访问某个资源==
可简单理解为信号量为一个数值：
- 当信号量 > 0，表示资源可用，获取信号量时系统自动将信号量减1
- 当信号量 == 0，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒
## 数据结构
```go
// src/sync/waitgroup.go:WaitGroup
type WaitGroup struct {
	state1 [3]uint32
}
```
state1是个长度为3的数组，其中包含了state和一个信号量
- counter： 当前还未执行结束的goroutine计数器
- waiter count: 等待goroutine-group结束的goroutine数量，即有多少个等候者
- semaphore: 信号量
![[Pasted image 20250429231919.png]]
## 对外接口
- Add(delta int): 将`delta`值加到`counter`中
- Wait()： `waiter`递增1，并阻塞等待信号量`semaphore`
- Done()： `counter`递减1，按照`waiter`数值释放相应次数信号量
### Add(delta int)
1. 把`delta`值加到`counter`中
2. 当`counter`变成`0`，根据`waiter`数值释放等量的信号量，把等待的goroutine全部唤醒，如果counter变为负值，则panic
伪码
```go
func (wg *WaitGroup) Add(delta int) {
    statep, semap := wg.state() //获取state和semaphore地址指针

    state := atomic.AddUint64(statep, uint64(delta)<<32) //把delta左移32位累加到state，即累加到counter中
    v := int32(state >> 32) //获取counter值
    w := uint32(state)      //获取waiter值

    if v < 0 {              //经过累加后counter值变为负值，panic
        panic("sync: negative WaitGroup counter")
    }

    //经过累加后，此时，counter >= 0
    //如果counter为正，说明不需要释放信号量，直接退出
    //如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出
    if v > 0 || w == 0 {
        return
    }

    //此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），
    //先把counter置为0，再释放waiter个数的信号量
    *statep = 0
    for ; w != 0; w-- {
        runtime_Semrelease(semap, false) //释放信号量，执行一次释放一个，唤醒一个等待者
    }
}
```

### Wait()
1. 累加`waiter`
2. 阻塞等待信号量
```go
func (wg *WaitGroup) Wait() {
    statep, semap := wg.state() //获取state和semaphore地址指针
    for {
        state := atomic.LoadUint64(statep) //获取state值
        v := int32(state >> 32)            //获取counter值
        w := uint32(state)                 //获取waiter值
        if v == 0 {                        //如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回
            return
        }

        // 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试
        if atomic.CompareAndSwapUint64(statep, state, state+1) {
            runtime_Semacquire(semap) //累加成功后，等待信号量唤醒自己
            return
        }
    }
}
```

### Done()
- `conter`减一
```go
func (wg *WaitGroup) Done() {
    wg.Add(-1)
}
```

## 小结
简单说来，`WaitGroup`通常用于等待一组“工作协程”结束的场景
`WaitGroup`对外提供的三个方法分工非常明确：
- `dd(delta int)`方法用于增加“工作协程”计数，通常在启动新的“工作协程”之前调用；
- `Done()`方法用于减少“工作协程”计数，每次调用递减`1`，通常在“工作协程”内部且在临近返回之前调用；
- `Wait()`方法用于增加“坐等协程”计数，通常在所有”工作协程”全部启动之后调用；

---
