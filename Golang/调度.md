1. **进程**：是操作系统**资源分配**的基本单位
2. **线程**：是操作系统**CPU调度**的基本单位
3. **协程**：是**用户态的轻量级线程**
# goroutine/thread的不同
1. ==内存消耗==
	1. 创建一个 goroutine 的栈内存消耗为 2 KB，如果栈空间不够用，会自动进行扩容
	2. 创建一个 thread 需要消耗 1 MB 栈内存，还需要一个被称为 "a guard page" 的区域 用于和其他 thread 的栈空间进行隔离
2. ==创建与销毁==
	1. goroutine 由 Go runtime 负责管理，创建和销毁的消耗很小，是用户级的
	2. thread 创建销毁内核级的，解决消耗大的方法是使用线程池，尽量复用
3. ==切换==
	1. goroutine 切换只需要保存：Program Counter、Stack Pointer 和BP
	2. thread 切换，需要各种寄存器，以便将来恢复，包括：16 general purpose registers, PC (Program Counter)、SP (Stack Pointer)、segment registers、16 XMM registers、FP coprocessor state、16 AVX registers、all MSRs etc

> [!寄存器：]
> 1. PC（Program Counter）：程序计数器  
> 	在切换goroutine时，需要保存当前的PC值，以便在恢复时能够继续从中断的地方执行
> 2. SP（Stack Pointer）：栈指针  
> 	保存SP值，确保在恢复时栈的状态保持正确，能够正确管理函数调用和返回
> 3. BP（Base Pointer）：基址指针  
> 	保存BP值，确保在恢复时能够正确地访问栈上的变量和参数

---
# GMP
![[0079ba82fa584272b26ffe27442c11be~tplv-73owjymdk6-jj-mark-v1_0_0_0_0_5o6Y6YeR5oqA5pyv56S-5Yy6IEAg5Y2c6ZSm5YWD_q75.webp]]
GMP高效地实现了==高并发协程调度执行==，解决了用户态调度和内核态线程之间的映射关系

| 策略/优化名        | 含义与作用                           | 目的                              |
| ------------- | ------------------------------- | ------------------------------- |
| Work Stealing | 空闲的 P 会从其他 P 偷 G（偷一半）           | 实现 Goroutine 调度的负载均衡            |
| G 抢占          | 避免单个 Goroutine 长时间占用 CPU，异步抢占机制 | 保障并发的 “公平性”，避免某段计算密集型代码垄断 CPU   |
| syscall 处理    | 阻塞 syscall 会释放 P，由新的 M 接管       |                                 |
| GMP 池机制       | 尽可能复用 M（线程）和 G，降低创建成本           | 降低 M 和 G 的创建 / 销毁成本             |
| 全局 G 队列       | 本地队列满时，G 会进入全局队列                | 作为 “兜底” 的调度队列，避免 G 因本地队列满而无法被调度 |

---
# Go sheduler
Go 程序的执行有两个层面：`Go Program` 和 `Runtime`，即用户程序和运行时
它们之间通过函数调用来实现内存管理、channel 通信、goroutine 创建等功能

![[Pasted image 20250427204922.png|339]]
`Runtime`：维护所有的`goroutine`，通过`scheduler`来进行调度
操作系统看来，所有的程序都是执行在多线程，将`goroutine`调度到线程上执行，仅仅是`runtime`层面的一个概念，是操作系统之上的层面，操作系统并不能感知到`goroutine`的存在


`GMP`模型是用来高效管理和调度Go语言中的 `goroutine`（协程）
主要目的解决并发编程中的一些问题：
1. ==轻量级并发==：`GMP`模型允许创建大量的 `goroutine`，每个 `goroutine` 占用的内存和系统资源非常少，因此可以在同一时间运行成千上万的协程
2. ==高效调度==：`GMP`将 `goroutine` 映射到操作系统的线程上，并通过调度器来管理它们
3. ==阻塞和唤醒处理==：`GMP`模型有效地处理阻塞操作，例如网络 I/O 和文件 I/O
4. ==负载均衡==：模型通过动态调度和工作窃取等机制，确保在多核 CPU 上的负载均衡，使得所有 CPU 核心都能充分利用

`G M P`是`Go scheduler`的三个核心组件，在它们精密的配合下，Go 调度器才得以高效运转，这也是 Go 天然支持高并发的内在动力、
==`G` 需要在 `M` 上才能运行，`M` 依赖 `P` 提供的资源，`P` 则持有待运行的 `G`==
有三个基础的结构体来实现`goroutine`的调度：
- `G`：`goroutine`，包含表示 goroutine 栈 的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址
- `M`：`machine`内核线程，包含`M`自身的栈信息、正在运行的`goroutine`、与之绑定的`P`信息等字段，==当`M`没有工作可做的时候，在它休眠前，会"自旋"地来找工作：检查全局队列，查看 network poller，试图执行 GC 任务，或者"偷"工作==
- `P`：一个虚拟的`Processor`，维护一个处于`Runnable`状态的`gorouine`队列

还有一个核心的结构体：sched，它总揽全局，维持整个调度器的运行
==Runtime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一 个 M 用来开始 G 的运行。随着时间的推移，更多的 G 会被创建出来，更多的 M 也会被创建出来==
![[Pasted image 20250427213837.png|425]]

在 Go 的早期版本，并没有 P 这个结构体，M 必须从一个全局的队列里获取要运行的 G
并且会创建一 个 M 用来开始 G 的运行，随时间推移，`G` 的创建带动 `M` 的创建
当并发量大的时候，锁就成了瓶颈
后来调度器在 Dmitry Vyokov 里，加 上了 P 结构体。每个 P 维护一个处于 Runnable 状态的 G 的队列，解决了原来的全局锁问题

==Go scheduler 的目标：将 goroutine 调度到内核线程上==
Go scheduler 的核心思想是： 
1. 重用线程
2. 限制同时运行（不包含阻塞）的线程数为 N，N 等于 CPU 的核心数目
3. 线程私有 runqueues，并且可以从其他线程偷取 goroutine 来运行，线程阻塞后，可以将 runqueues 传递给其他线程

==需要`P`组件的原因==：
1. 当一个线程阻塞的时候，将和它绑定的`P`上的`goroutine`转移到其他线程
2. 每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少

```go
fmt.Println(runtime.NumCPU())
// 打印12
```
==`P`默认为CPU逻辑核心数==
==程序中可以使用`runtime.GOMAXPROCS()`设置P的个数==
Go程序启动后，会给每个逻辑核心数分配一个`P`（Logic Proccer)
会给每个 `P` 分配 一个 `M`（Machine，表示内核线程），这些内核线程仍然由操作系统来调度
这里在本地启动一个 Go 程序时，会得到 12 个系统线程去执行任务，每个线程会搭配一个 P

## M:N模型
`Go runtime`负责`goruntine`的创建到销毁，在程序启动后，"按需"创建`N`个线程（`CPU`执行调度的单位），之后创建的`M`个`goroutine`都会依附在这`N`个线程上执行

![[Pasted image 20250427212728.png]]
这里8个`G`依附在2个系统线程上，并得到执行
同一时刻，一个线程上只能跑一个`goroutine`，当`goroutine`发生阻塞，`runtime`会把当前的`goroutine`调度走，让其他`goroutine`来执行，目的就是不让一个线程闲着

## 工作窃取
`Go scheduler`的职责：所有处于`runnable`的`goroutine`均匀调度到`P`上运行的`M`
当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行
为了全局的利益，主动为别人分担，就被称为工作窃取（Working-stealing）
`Go scheduler`每一轮调度要做的工作就是找到处于 `runnable` 的 `goroutine`，并执行它
找的顺序：
1. 从本地可运行队列里找
2. 从全局可运行队列里找
3. 从`netpoll`里找（是否有已准备好的网络请求，如接收数据的`goroutine`）
4. 从其他`P`偷取

==`hand off`：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行==
==抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死==

## 调度流程

![[Pasted image 20250427220349.png]]
- 创建一个 `G`
	- 如果本地队列没满，则随机放入一个未满的本地队列，否则放入全局队列。
- 执行 `G`
	- `P` 会获取一个 `G` 在 `M` 中执行，若 `G` 产生 `systemCall` 阻塞，则会将 `M` 放入休眠队列，并从休眠队列中取出一个 `M` 接管 `P` 执行，若休眠队列为空则创建一个新的 `M` 来接管 `P`。
- 获取 `G`
	- 若本地队列中 `G` 已经执行完，则尝试从从全局队列中获取 `G`，若全局队列中没有可运行的 `G`， 则从其他 `P` 的本地队列中偷取 `G`
## 调度器的生命周期
![[Pasted image 20250427215942.png]]

- `M0`：`M0` 是主线程创建的第一个线程，负责创建和运行第一个 `G`, 存储在 `runtime.m0` 中，不需要在 `Heap` 上分配
- `G0`：`0` 创建之后会立即创建一个 `G0` , 这个 `G0` 只用于调度 `G`， 不执行逻辑代码， `G0` 和 `M0` 对应