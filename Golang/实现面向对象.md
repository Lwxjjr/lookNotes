> [!info] 面向对象的基本特征
> - **封装**
> 	把客观客观事物封装成抽象的类
> 	类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
> - **继承**：
> 	它可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展
> - **多态**
> 	允许你将父对象设置成为和一个或更多的他的子对象相等的技术

## 面向过程与面向对象对比
- 面向过程是一种以==事件为中心==的编程思想，把解决问题的步骤分析出来，使用函数把这些步骤实现，在一步步的具体步骤中按顺序调用函数
- 面向对象是一种以==对象为中心==的编程思想，把要解决的问题分解成各个对象，建立对象的目的是为了描述某个对象在整个解决问题的步骤中的属性和行为

![[Pasted image 20250513230855.png|320]]![[Pasted image 20250513230926.png|316]]
> [!example] 以五子棋为例子
> **面向过程的设计思路是**：
> 使用函数实现下面的步骤，在五子棋的主函数中依次调用
> 1. 开始游戏
> 2. 黑方落子
> 3. 绘制画面
> 4. 判断输赢
> 5. 白方落子
> 6. 绘制画面
> 7. 判断胜负
> 8. 返回步骤
> 9. 输出最后结果  
> 
> **面向对象的设计思路是**：
> 设计三个对象
> - 黑白落子
> - 棋盘绘图
> - 规则逻辑
>  
>调用逻辑：
> 1.【黑白落子】接收用户输入
> 2. 告知【棋盘绘图】记录布局变化，并作出显示
> 3. 再利用【规则逻辑】判断胜负

==可以看出，面向对象是以功能来划分问题，而不是以步骤解决==
> [!info] 悔棋功能
> 在面向过程中，从输入到显示再到最后判断的整个步骤都要改动，甚至函数的调用顺序也要改动
> 在面向对象的设计中，只需在棋盘系统中增加一个回溯的功能就可以了

---
## Go是面向对象的语言吗
![[Pasted image 20250513232843.png]]
> [!info] Yes and no
> - Go 有类型和方法，并且允许面向对象的编程风格，但没有类型层次
> - Go 中的 "接口 "概念提供了一种不同的方法，有一些方法可以将类型嵌入到其他类型中，以提供类似的东西，但不等同于子类
> - Go 中的方法比 C++ 或 Java 中的方法更通用：它们可以为任何类型的数据定义，甚至是内置类型，如普通的、"未装箱的 "整数。它们并不局限于结构（类）


---
## Go实现面向对象编程
### 封装
> [!tip] 面向对象中的 “封装” 指的是可以隐藏对象的内部属性和实现细节，仅对外提供公开接口调用

在 Go 语言中的属性访问权限，通过首字母大小写来控制：
- 首字母大写，代表是公共的、可被外部访问的。
- 首字母小写，代表是私有的，不可以被外部访问

```go
type Animal struct {  
	name string  
}  
  
func NewAnimal() *Animal {  
	return &Animal{}  
}  
  
func (p *Animal) SetName(name string) {  
	p.name = name  
}  
  
func (p *Animal) GetName() string {  
	return p.name  
}
```
我们声明了一个结构体 `Animal`，其属性 `name` 为小写
在配套上存在 `Setter` 和 `Getter` 的方法，用于统一的访问和设置控制

### 继承
> [!tip] 面向对象中的 “继承” 指的是子类继承父类的特征和行为
> > [!example] 例如动物是一个大父类，下面又可以细分为"食草动物"，"食肉动物" 

在 Go 语言中，是没有类似 `extends` 关键字的这种继承的方式，
==在语言设计上采取的是组合的方式==
```go
type Animal struct {  
	Name string  
}  
  
type Cat struct {  
	Animal  
	FeatureA string  
}  
  
type Dog struct {  
	Animal  
	FeatureB string  
}
```
我们声明了 `Cat` 和 `Dog` 结构体，其在内部匿名组合了 `Animal` 结构体。因此 `Cat` 和 `Dog` 的实例都可以调用 `Animal` 结构体的方法
同时 `Cat` 和 `Dog` 的实例可以拥有自己的方法

### 多态
> [!tip] 面向对象中的 “多态” 指的同一个行为具有多种不同表现形式或形态的能力

在 Go 语言中，多态是通过接口来实现的：
```go
type AnimalSounder interface {  
	MakeDNA()  
}  
  
func MakeSomeDNA(animalSounder AnimalSounder) {  
	animalSounder.MakeDNA()  
}
```

只要配套的 `Cat` 和 `Dog` 的实例也实现了 `MakeSomeDNA` 方法，那么我们就可以认为他是 `AnimalSounder` 接口类型：
```go
type AnimalSounder interface {  
	MakeDNA()  
}  
  
func MakeSomeDNA(animalSounder AnimalSounder) {  
	animalSounder.MakeDNA()  
}  
  
func (c *Cat) MakeDNA() {  
	fmt.Println("煎鱼是煎鱼")  
}  
  
func (c *Dog) MakeDNA() {  
	fmt.Println("煎鱼其实不是煎鱼")  
}  
  
func main() {  
	MakeSomeDNA(&Cat{})  
	MakeSomeDNA(&Dog{})  
}
```
