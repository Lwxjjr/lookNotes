# Redis 如何实现延迟队列？

在 Redis 可以使用有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间

![[延迟队列.webp]]


---
# Redis的大Key如何处理？
## 什么是大Key?
大 key 并不是指 key 的值很大，而是 ==key 对应的 value 很大==

一般而言，下面这两种情况被称为大 key：
- String 类型的值大于 10 KB；
- Hash、List、Set、ZSet 类型的元素的个数超过 5000个

## 大 key 会造成什么问题？
1. **客户端超时阻塞**：Redis 执行命令是单线程处理，==操作大 key 时会比较耗时==，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应
2. **引发网络阻塞**：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的
3. **阻塞工作线程**：如果==使用 del 删除大 key 时，会阻塞工作线程==，这样就没办法处理后续的命令
4. **内存分布不均**：集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大

## 如何找到大 key ？
### _**1、redis-cli --bigkeys 查找大key**_
```
redis-cli -h 127.0.0.1 -p6379 -a "password" -- bigkeys
```
问题：
- 这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey
- 对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大

### _**2、使用 SCAN 命令查找大 key**_
使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型  
==对于 String 类型==，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数
==对于集合类型来说==，有两种方法可以获得它占用的内存大小：
- 如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：`LLEN` 命令；Hash 类型：`HLEN` 命令；Set 类型：`SCARD` 命令；Sorted Set 类型：`ZCARD` 命令；
- 如果不能提前知道写入集合的元素大小，可以使用 `MEMORY USAGE` 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间

### _**3、使用 RdbTools 工具查找大 key**_
使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key


## 如何删除大 key？
删除操作的本质是要释放键值对占用的内存空间  
释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要==把释放掉的内存块插入一个空闲内存块的链表==，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序

如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞  
删除大 key：
1. 分批次删除
2. 异步删除（Redis 4.0版本以上）

### _**1、分批次删除**_
1. **删除大 Hash**，使用 `hscan` 命令，每次获取 100 个字段，再用 `hdel` 命令，每次删除 1 个字段
2. **删除大 List**，通过 `ltrim` 命令，每次删除少量元素
3. **删除大 Set**，使用 `sscan` 命令，每次扫描集合中 100 个元素，再用 `srem` 命令每次删除一个键
4. **删除大 ZSet**，使用 `zremrangebyrank` 命令，每次删除 top 100个元素
 
### _**2、异步删除**_
从 Redis 4.0 版本开始，可以采用**异步删除**法，==**用 unlink 命令代替 del 来删除**==  
这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程  
```shell
//当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除
lazyfree-lazy-eviction 
// 设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除
lazyfree-lazy-expire
// 有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除
lazyfree-lazy-server-del
// 针对 slave (从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除
slave-lazy-flush
```


# Redis管道有什么用？

管道技术（Pipeline）是==客户端提供的一种批处理技术==，用于一次处理多个 Redis 命令，从而提高整个交互的性能  
管道技术本质上是客户端提供的功能，而非 Redis 服务器端的功能  

普通命令模式：
![[普通命令模式.webp]]
管道模式：
![[管道模式.webp]]

使用==**管道技术可以解决多个命令执行时的网络等待**==  
使用管道技术也要注意避免发送的命令过大，或管道内的数据太多而导致的网络阻塞


