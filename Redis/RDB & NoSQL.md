## 选择NoSQL的背景
MySQL在==高并发场景==下可能会**面临性能瓶颈、数据库连接压力、锁竞争、缓存不足和扩展性受限等问题**
> 1. 单机MySQL时代（90年代）,一个网站的访问量一般不会太大，单个数据库完全够用

![[Pasted image 20250317205909.png]]
问题：
- 数据量增加到一定程度，单机数据库就放不下了
- 数据的索引（B+ Tree），**一个机器内存**也存放不下
- 访问量变大后（读写混合），**一台服务器**承受不住

> 2. MySQL + MemCache（缓存）+ 垂直拆分（读写分离）

![[Pasted image 20250317210038.png]]
将当个数据库扩展成为多个“垂直”的数据库，同时满足**读写分离和数据一致性**  
但是当访问量过大时频繁去数据库查询速度和效率低下。  
这个优化过程经历了以下几个过程：

- 优化数据库的数据结构和索引(难度大)
- 文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了
- MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升
> 3、分库分表、主从复制 => 集群

![[Pasted image 20250317210301.png]]

> 4. 如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据库（RDBMS）无法满足大量数据要求。Nosql数据库就能轻松解决这些问题

---
## RDB
关系数据库基于**关系模型**，这是一种在表中表示数据的**直观，直接**的方法。
在关系数据库中，表中的<u>每一行都是一条记录</u>，该记录具有唯一的ID（称为_key)。该表的列保存数据的属性，每个记录通常为每个属性都有一个值，这使得在数据点之间建立关系变得容易

**优点：**  
1. **易于维护**：都是使用表结构，**格式一致**
2. **使用方便**：**SQL语言通用**，可用于复杂查询
3. **复杂操作**：**支持SQL**，可用于一个表以及多个表之间非常复杂的查询 

**缺点：**  
1. **读写性能比较差**，尤其是海量数据的高效率读写
2. 固定的表结构，**灵活度稍欠**
3. 高并发读写需求，传统关系型数据库来说，**硬盘I/O是一个很大的瓶颈**
--- 
## NoSQL
Nosql的全称是Not Only Sql，随着互联网的高速发展，传统的关系型数据库在应付超大规模，超大流量以及高并发的时候力不从心。而就在这个时候，Nosql得到的高速的发展
非关系型数据库严格来说是**一种<u>数据结构化</u>存储方法的集合，可以是文档或者键值对等**

**优点**：
1. **格式灵活**：存储数据的格式可以是**key-value形式、列存储、文档形式、图形数据库等等**，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。
2. **速度快**：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；
3. 高扩展性；
4. 成本低：nosql数据库部署简单，基本都是开源软件。

**缺点**：
1. 不提供sql支持，学习和使用成本较高；
2. 无事务处理；
3. 数据结构相对复杂，复杂查询方面稍欠
---
## Diff(RDB & NoSQL)

#### 1.存储方式
- **关系型数据库是表格式的**，因此存储在表的行和列中。他们之间很容易**关联协作存储**，提取数据很方便。
- Nosql数据库则与其相反，他是大块的组合在一起。通常存储在数据集中
#### 2.存储结构
- 关系型数据库对应的是**结构化数据**（预定义结构带来了可靠性和稳定性，但是修改这些数据比较困难），为了更高的规范性，把数据分割为最小的关系表以避免重复，获得精简的空间利用  
- NoSQL数据库基于**动态结构**（这种灵活性使得NoSQL数据库能够根据实际需求调整数据结构，而**无需进行繁琐的表结构更改**），**储在平面数据集中**，存储成了一个整体，这样整块数据更加便于读写
#### 3.存储扩展（最大的区别）
- 关系型数据库是**纵向扩展**，也就是说想要提高处理能力，要使用速度更快的计算机  
- Nosql数据库是**横向扩展的**，它的存储天然就是**分布式的**，可以通过给资源池添加更多的普通数据库服务器来分担负载
#### 4.事务
- 关系型数据库遵循[[事务#ACID原则]]
- NoSQL数据库遵循**BASE原则**  

分布式系统设计：
1. CAP理论
2. BASE原则

### CAP理论

![[Pasted image 20250321170802.png]]
CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：
- 一致性（Consistency）:保持所有结点在同一时刻具有相同的/逻辑一致的数据
- 可用性（Availability）:保证每个请求不管成功或者失败都有响应
- 分区容错性（Partition Tolerance）:系统中任何的信息丢失或者失败都不会影响系统的继续运作，分布式系统出现==网络分区的时候，仍然能够对外提供服务==
#### 网络分区
分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 **网络分区**

![[Pasted image 20250321171117.png]]

> [!info] 不是所谓的 "3 选 2" 
> **当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。**  
> 简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C

==**分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构**==  

#### 为什么不能选择CA架构？（网络分区的AC冲突）
举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了



---
### BASE原则

核心理念：
即使==无法做到强一致性==，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性
![[640 4.webp]]
AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方

#### 基本可用
分布式系统在出现不可预知故障的时候，==允许损失部分可用性，不等于系统不可用==
1. ==允许响应时间上的损失==：正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s
2. ==允许系统功能上的损失==：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，**系统的部分非核心功能无法使用**

#### 软状态
软状态指允许系统中的数据存在中间状态（**CAP 理论中的数据不一致**），并认为该中间状态的存在==不会影响系统的整体可用性==

#### 最终一致性
系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态  
本质是需要系统保证最终数据能够达到一致，而==不需要实时保证系统数据的强一致性==  
### **总结**

- ACID 是数据库事务完整性的理论
- CAP 是分布式系统设计理论
- BASE 是 CAP 理论中 AP 方案的延伸。