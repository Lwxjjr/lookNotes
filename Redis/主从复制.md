如果数据都是存储在一台服务器上：
- 服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的
- 这台服务器的硬盘出现了故障，可能数据就都丢失了

要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，==这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务==

![[22c7fe97ce5d3c382b08d83a4d8a5b96.webp]]


Redis 提供了**主从复制模式**来保证多台服务器的数据一致性，主从服务器之间采用的是==读写分离的方式==
==数据的复制是单向的，只能由主节点到从节点==



![[2b7231b6aabb9a9a2e2390ab3a280b2d-20230309232920063.webp]]

---
# 主从复制的作用
1. **读写分离**：主节点写，从节点读，提高服务器的读写负载能力
2. **数据冗余**：==主从复制实现了数据的热备份==，是持久化之外的一种数据冗余方式。
3. **故障恢复**︰当主节点出现问题时，可以由从节点提供服务
4. **负载均衡**︰在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载 ; 尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量
5. 高可用：哨兵集群

---
# 主从复制工作流程
1. 建立连接
2. 数据同步
3. 命令传播
## 连接
### 主从连接
使用 `replicaof` 命令形成主服务器和从服务器的关系
比如，现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：

1. 客户端发送命令
```shell
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>

打开redis服务端 
redis-server redis_config/redis-6379.conf # 主机
redis-server redis_config/redis-6380.conf # 从机

[root@lwx bin]# redis-cli -p 6380
127.0.0.1:6380> slaveof 127.0.0.1 6379
```

2. 启动服务器参数
```shell
redis-server -slaveof <masterip> <masterport>

在命令行直接连接 
[root@lwx bin]# redis-server redis_config/redis-6380.conf --slaveof 127.0.0.1 6379
```

3. 配置文件修改
```shell
[root@lwx bin]# vim redis-6380.conf
添加
slaveof 127.0.0.1 6379
```


```shell
info replication // 查看定位

主节点
127.0.0.1:6379> info replication
# Replication
role:master
connected_slaves:1

从节点
127.0.0.1:6380> info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
```

### 断开连接
在从机上发送命令
slave断开连接后，不会删除已有数据，只是不再接受master发送的数据
```shell
slaveof no one
```

---
## 同步

![[ea4f7e86baf2435af3999e5cd38b6a26.webp]]

_==第一阶段：建立链接、协商同步==_

执行了 `replicaof` 命令后，从服务器就会给主服务器发送 `psync` 命令，==表示要进行数据同步==，`psync`命令包含两个参数，分别是==主服务器的`runID`和复制进度`offset==`
- runID，每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。第一次同步时，因为不知道主服务器的 `run ID`，所以将其设置为 "?"
- offset，表示复制的进度。第一次同步时，其值为 -1

主服务器收到 `psync` 命令后，会用 `FULLRESYNC` 作为响应命令返回给对方，并带上两个参数，主服务器的`run ID`和主服务器目前的复制进度`offset`，从服务器接收并记录
> [!info] FULLRESYNC：意图采用全量复制

==_第二阶段：主服务器同步数据给从服务器_==
主服务器会执行 `bgsave` 命令来生成 `RDB` 文件，然后把文件发送给从服务器
从服务器收到 `RDB` 文件后，会先清空当前的数据，然后载入 `RDB` 文件
> [!warning] 但是这期间生成的写操作命令并没有记录到刚刚生成的 `RDB` 文件，这时主从服务器之间的数据就不一致了

为了保持主动服务器的一致性，主服务器在下面这3个时间间隙中将收到的写操作命令，写入到 `replication buffer` 缓存区里：
- 「主服务器」生成 RDB 文件期间；
- 「主服务器」发送 RDB 文件给从服务器期间；
- 「从服务器」加载 RDB 文件期间；

==_第三阶段：主服务器发送新写操作命令给从服务器_==
从服务器完成 RDB 的载入后，会回复一个确认消息给主服务器
接着会把`replication buffer` 缓存区里中所记录的写操作命令发送给从服务器
`slave`发送命令：`psync runid offset`，`master`判断`runid`是否匹配，判定`offset`是否在复制缓冲区中，但凡有一个不满足，重复全量复制，校验通过则执行增量复制


![[Pasted image 20250510220143.png]]


> [!info] 注意
> 1. 如果master数据量巨大，数据同步阶段应==避开流量高峰期==，避免造成master阻塞，影响业务正常执行
> 2. 复制缓冲区大小设定不合理，会导致==数据溢出==。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入==死循环==状态
> ```shell
> 修改复制缓冲区大小 
> repl-backlog-size 1mb 默认1mb
> ```
> 3. master单机内存占用主机内存的比例==不应过大==，建议使用==50%-70%的内存==，留下30%-50%的内存用于执行bgsave命令和创建复制缓冲区


---
## 命令传播
主从服务器在完成第一次同步后，双方之间就会维护一个 ==TCP 长连接==
**基于长连接的命令传播**，通过这种方式来保证第一次同步后的主从服务器的数据一致性

![[03eacec67cc58ff8d5819d0872ddd41e.webp]]



---
# 分摊主服务器的压力
从服务器数量非常多，而且==都与主服务器进行全量同步的话==，就会带来两个问题：
- 由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求
- 传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响

> [!example]
> 公司发展起来，人员的扩充，老板慢慢就无法承担全部员工的管理工作了

==Redis 也是一样的，从服务器可以有自己的从服务器==

![[4d850bfe8d712d3d67ff13e59b919452.webp]]

通过这种方式，**主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器**

---
## 增量传播
如果主从服务器间的网络连接断开了，那么就无法进行命令传播了，这时从服务器的数据就没办法和主服务器保持一致了，客户端就可能从「从服务器」读到旧的数据

![[4845008abadaa871613873f5ffdcb542.webp]]

`Redis 2.8`之前，主从服务器在命令同步时出现了网络断开又恢复的情况，==从服务器就会和主服务器重新进行一次全量复制==，很明显这样的开销太大了
`Redis 2.8`以后，网络断开又恢复后，从主从服务器会采用==**增量复制**==的方式，即==把网络断开期间主服务器接收到的写操作命令，同步给从服务器==

![[e081b470870daeb763062bb873a4477e.webp]]

网络恢复后的增量复制过程：
1. 从服务器在恢复网络后，会发送 psync 命令给主服务器，此时的 psync 命令里的 offset 参数不是 -1
2. 主服务器收到该命令后，然后用 ==CONTINUE 响应命令告诉从服务器接下来采用增量复制的方式同步数据==
3. 然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令

> [!tip] 主服务器怎么知道要将哪些增量数据发送给从服务器呢
> - **repl_backlog_buffer**，是一个「**环形**」缓冲区，用于主从服务器断连后，从中找到差异的数据；
> - **replication offset**，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 master_repl_offset 来记录自己「写」到的位置，从服务器使用 slave_repl_offset 来记录自己「读」到的位置。

> [!info] 操作
> 在主服务器进行命令操作的时候，不仅会将写命令发送给从服务器，还会将写命令写入到`repl_backlog_buffer`缓冲区里
> 网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量 `slave_repl_offset` 发送给主服务器，主服务器根据自己的 `master_repl_offset` 和 `slave_repl_offset` 之间的差距，然后来决定对从服务器执行哪种同步操作：
> - 要读取的数据在repl_backlog_buffer缓冲区里，采用增量同步
> - 要读取的数据不在repl_backlog_buffer缓冲区里，采用全量同步

![[2db4831516b9a8b79f833cf0593c1f12.webp]]


---
# Redis节点判断是否工作
==`ping-pong`心跳检测机制==
如果有一半以上的节点去 ping 一个节点的时候没有 pong 回应，集群就会认为这个节点挂掉了，会断开与这个节点的连接
- Redis 主节点默认每隔 10 秒对从节点发送 `ping` 命令，判断从节点的存活性和连接状态，可通过参数`repl-ping-slave-period`控制发送频率
- Reids从节点每隔 1 秒发送 `replconf ack{offset}` 命令，给主节点上报自身当前的复制偏移量，目的是为了：
	- 实时监测主从节点网络状态；
	- 上报自身复制偏移量，检查复制数据是否丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据

---
# 主从复制架构，过期Key怎么处理
主节点处理了一个key或者通过淘汰算法淘汰了一个key，这个时间主节点模拟一条del命令发送给从节点，从节点收到该命令后，就进行删除key的操作

---
# Redis是异步复制
Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后异步发送给从节点

---
# 主从数据不一致
主从数据不一致，就是指客户端从从节点中读取到的值和主节点中的最新值并不一致
出现这种情况的原因是：==主从节点间的命令复制是异步进行的==，所以无法实现强一致性保证（异步进行的：主节点在执行写操作后，并不需要等待从节点确认已经收到或应用这些变化，就立即继续处理其他任务）

应对主从数据不一致的方法：
1. 尽量保证主从节点间的网络连接状况良好，避免主从节点在不同的机房
2. 开发一个外部程序来监控主从节点间的复制进度


---
# 主从切换如何减少数据丢失
主从切换过程中，产生数据丢失的情况有两种：
- 异步复制同步丢失
- 集群产生脑裂数据丢失

## 异步复制同步丢失
Redis 主节点与从节点之间的数据复制，是异步复制的，如果主节点没来得及同步给从节点时发生了断电，那么主节点内存中的数据会丢失

> [!减少异步复制同步丢失方案]

Redis配置参数`min-slaves-max-log`：表示一旦所有的从节点数据复制和同步的延迟都超过了 `min-slaves-max-lag` 定义的值，那么主节点就会拒绝接收任何请求
对于客户端，当发现 `master` 不可写后，我们可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间（等 master 恢复正常）后重新写入 master 来保证数据不丢失，也可以将数据写入 kafka 消息队列，等 master 恢复正常，再隔一段时间去消费 kafka 中的数据，让将数据重新写入 master

## 集群产生脑裂数据丢失
Redis主从架构中，部署方式一般都是【一主多从】，主节点提供写操作，从节点提供读操作
但是主节点的网咯突然发生了问题，它与所有的从节点都失联了，但是主节点和客户端的网络是正常的，这个客户端并不知道Redis内部出现了问题
同时哨兵发现主节点失联了，网络出现问题，认为主节点挂了，==哨兵就会从节点中选举一个`leeder`作为主节点，这个时候集群就会有`2`个主节点 -- 脑裂出现了==

这个时候网络突然好了，由于哨兵之前已经选举了一个新主节点，它会把旧主节点（A）降级为从节点，从节点（A）会向新主节点请求数据同步，==**因为第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步。所以，之前客户端在过程 A 写入的数据就会丢失了，也就是集群产生脑裂数据丢失的问题**==

总结：
- 由于网络问题，集群节点之间失去联系，主从数据不同步
- 重新平衡选举，产生两个主服务
- 等网络恢复，旧主节点会降级为从节点
- 旧主节点与新主节点进行同步复制的时候，由于从节点会清空自己的缓冲区
- 导致之前客户端写入的数据丢失了

> [!减少脑裂的数据丢失方案]

Redis配置文件参数：
- `min-slaves-to-write x`：主节点必须有至少`x`个节点连接，小于这个数，主节点会禁止写数据
- `min-slaves-max-lag x`：主从数据复制和同步的延迟不能超过`x`秒，超过这个数，主节点会禁止写数据

联合这2个配置项，==**主节点连接的从节点中至少有 N 个从节点，「并且」主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒**==，否则，主节点就不会再接收客户端的写请求了




---
# 主从故障自动切换
主节点挂了 ，从节点是无法自动升级为主节点的，这个过程需要人工处理，在此期间 Redis 无法对外提供写操作。

此时，Redis 哨兵机制就登场了，哨兵在发现主节点出现故障时，由哨兵自动完成故障发现和故障转移，并通知给应用方，从而实现高可用性。