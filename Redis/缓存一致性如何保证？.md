### 缓存是什么？
缓存就是把低速存储的结果，临时保存在高速存储，以提高查询效率

### 为什么需要缓存？
关系型数据库如mysql，通常支持完整的ACID特性，即原子性、一致性、隔离性和持久性，==架构复杂，因而性能普遍较低==  
高并发的查询需求，会给mysql带来很大压力
- 造成数据库系统的不稳定
- 同时也容易产生延迟

根据==局部性原理==，80%的请求会落到20%热点数据上，在读多写少场景下，增加一层缓存非常有助提升==系统吞吐量和健壮性==  
可以看到，redis就像一个盾牌🛡️一样，帮助mysql分担请求，减轻压力

![[640.webp|625]]

### 存在问题？（数据一致性问题）
mysql的数据随着时间流逝，可能会发生更新，此时redis缓存数据就会落后，我们如何保证它们的一致性呢？

### 解决方案
#### 1. 等待过期，顺其自然
使用redis的过期时间，mysql更新时，redis不做处理，等待缓存过期失效，再从mysql拉取缓存
==和业务配置有关==，如果读请求非常频繁，且过期时间设置较长，则会产生很多脏数据  

优点：
- redis原生接口，开发成本低，易于实现；
- 管理成本低，出问题的概率会比较小

不足：
- 完全依赖过期时间，时间太短容易造成缓存频繁失效，太长容易有较长时间不一致，对编程者的业务能力，有一定要求

#### 2. 尝试删除，从头再来

![[640 1.webp]]
在方案一的基础上扩展，不光通过key的过期时间兜底，还需要在更新mysql时，同时尝试删除redis，如果删除成功，下次访问该数据，则会直接查询mysql的数据，此时再写入redis，就完成了数据同步 

优点：
- 相对方案一，达成最终一致性的延迟更小；
- 实现成本较低，只是在方案一的基础上，增加了删除逻辑。

不足：
- 如果更新mysql成功，删除redis却失败，就退化到了方案一；
- 在高并发场景，业务server需要和mysql、redis同时进行连接，这样是损耗双倍的连接资源，容易造成连接数过多的问题

#### 3. 主动更新，信箱投递

![[640 2.webp]]

1. 将更新操作交给==消息队列==，由消息队列保证可靠性
2. 再搭建一个==消费服务订阅消息队列==，来异步更新redis数据

优点：
- 使用消息队列，就相当于将请求投递至信箱，只要投递成功即完成任务，不用关心结果，实现了进一步解耦；
- 消息队列本身具有可靠性，在投递成功的前提下，通过手动提交等手段去消费，可以保证更新操作至少在redis中执行一次。

不足：
- 有时序性问题。举个栗子🌰，两台业务服务器在同一时间发出a = 1和a = 5两条请求，若mysql中先执行a=1再执行a=5，则mysql中a的值最终为5；但由于网络传输本身有延迟，所以无法保证两条请求谁先进入消息队列，最终redis的结果可能是1也可能是5，如果是1，mysql和redis中的数据就会产生不一致；
- 引入了消息队列，同时要增加消费服务，成本较高；
- 依旧有消耗更多客户端连接数的问题。

#### 4. 订阅日志，完全解耦

![[640 3.webp]]

把我们搭建的消费服务作为mysql的一个slave，订阅mysql的binlog日志，解析日志内容，再更新到redis。此方案和业务完全解耦，redis的更新对业务方透明，可以减少心智成本

优点：
- 在同步服务压力不大情况下，延迟较低；
- 和业务完全解耦，在更新mysql时，不需要做额外操作；
- 解决了时序性问题，可靠性强。

缺点：
- 要单独搭建一个同步服务，并且引入binlog同步机制，成本较大；
- 同步服务如果压力比较大，或者崩溃了，那么在较长时间内，redis中都是老旧数据。


#### 方案选择
1. 首先确认产品上对延迟性的要求，如果要求极高，且数据有可能变化，别用缓存。

2. 通常来说，方案1就够了。牛牛咨询过4、5个团队，基本都是用方案1，因为使用缓存方案，通常是读多写少场景，同时业务上对延迟具有一定的包容性。方案1虽然有一定延时，但比较实用。

3. 如果想增加更新时的即时性，就选择方案2，不过一定要注意，针对redis老数据的删除操作不要作为关键路径，影响核心流程。

4. 方案3、方案4均适用于对延时要求比较高的业务，其区别为前者是推模式，后者是拉模式，而后者具有更强的可靠性，且无时序性问题。既然都愿意花功夫做处理消息的逻辑，不如一步到位，用方案4