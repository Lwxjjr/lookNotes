Redis为了保证效率，把==数据缓存在内存中==  
**Redis 会周期性的把更新的数据写入磁盘/把修改操作写入追加的记录文件，以保证数据的持久化**  

Redis的持久化策略（==默认RDB==）：
1. AOF：把所有的对Redis的服务器进行修改的命令都存到一个文件里，命令的集合
2. RDB：快照形式是直接把内存中的数据保存到一个 dump 文件中，定时保存，保存策略

两种技术都会用各用一个日志文件来记录信息，但是记录的内容是不同的：
- AOF 文件的内容是==操作命令==
- RDB 文件的内容是==二进制数据==

当 Redis 重启时，它会==优先使用 AOF 文件来还原数据集==，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整

# AOF日志（Append Only File）

![[6f0ab40396b7fc2c15e6f4487d3a0ad7.webp]]
==**只会记录写操作命令**==
```c
// redis.conf
appendonly        yes               // 是否开启AOF持久化（默认 no，关闭）
appendfilename    "appendonly.aof"  // AOF持久化文件的名称
```

![[337021a153944fd0f964ca834e34d0f2.webp]]
- ==\*== 表示几个命令
- 每个部分以 ==$ + 数字== 开头，后面紧接具体命令、键、值
- 数字表示命令一共多少字节

## 为什么先写后记录日志？

优点：
1. ==避免额外的检查开销==，命令只有执行成功才写入AOF日志
2. ==不会阻塞当前写操作命令的执行==，写操作命令执行成功后，才会将命令记录到AOF日志

缺点：
1.  执行写操作命令和记录日志是两个过程，那当 Redis 在还没来得及将命令写入到硬盘时，服务器发生宕机了，这个数据就会有==**丢失的风险**==
2. 不会阻塞当前写操作命令的执行，但是==**可能会给「下一个」命令带来阻塞风险**==（写硬盘导致I/O压力太大，导致写硬盘速度很慢阻塞导致后续命令无法执行）

## 3种写回策略

Redis 写入 AOF 日志的过程  
1. 写操作追加 `server.aof_buf`
2. write() 系统调用，aof_buf -> AOF(page cache) —> 硬盘

![[4eeef4dd1bedd2ffe0b84d4eaa0dbdea.webp|550]]

`redis.conf` 配置文件 `appendfsync` 配置==具体内核缓冲区的数据什么时候写入到硬盘==：
1. ==Always==：每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘
2. ==Everysec==：每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘
3. ==No==：由操作系统决定何时将缓冲区内容写回硬盘

这 3 种写回策略都==无法能完美解决==「主进程阻塞」和「减少数据丢失」的问题，因为两个问题是==对立==的：
1. Always：可以最大程度保证数据不丢失，但是不可避免会影响主进程的性能
2. No：操作系统写回硬盘的时机是不可预知的，宕机会丢失不定数量的数据
3. Everysec：折中

根据业务选择：
1. No：高性能
2. Always：高可靠
3. Everysec：允许丢失一点 + 性能高

![[98987d9417b2bab43087f45fc959d32a.webp]]

### 实现机制：fsync()调用时机

![[f64829ffc2e9e006b090f9aae51035ee.webp|325]]

1. Always：每次写入 AOF 文件数据后，就执行 fsync() 函数
2. Everysec：创建一个异步任务来执行 fsync() 函数
3. No：永不执行 fsync() 函数


## AOF重写机制

AOF 日志文件过大就会带来性能问题，Redis重启恢复的过程会很慢  
==为了避免 AOF 文件越写越大==，提供了 **AOF 重写机制**  
达到阈值，启动AOF重写来压缩AOF文件  

![[723d6c580c05400b3841bc69566dd61b.webp]]
只关注 ==**「键值对」当前的最新状态**，**然后用一条命令去记录键值对**==  
等到全部记录完后，就将新的 AOF 文件==替换==掉现有的 AOF 文件  
==不直接复用现有的 AOF 文件==是因为**如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染**


## AOF后台重写

在触发 AOF 重写时需要读取所有缓存的键值对数据，并为每个键值对生成一条命令，然后将其写入到新的 AOF 文件，这个过程很耗时间，所以==重写的操作不能放在主进程里==  
Redis 的**重写 AOF 过程是由 ==后台子进程 _bgrewriteaof==_ 来完成的**  
### _后台子进程 bgrewriteaof 好处_
1. 子进程进行 AOF 重写期间，主进程可以继续处理命令请求，从而避免阻塞主进程
2. 子进程带有主进程的==数据副本==，这里==是进程不是线程==，多线程共享数据，需要加锁保证安全，会降低性能，而父子进程共享是只读的方式  
#### 子进程是怎么拥有主进程一样的数据副本的呢？

![[5a1f2a90b5f3821c19bea3b7a5f27fa1.webp]]

**页表**记录着==虚拟地址和物理地址映射关系==，而不会复制物理内存  
子进程就共享了父进程的物理内存数据了，这样能够**节约物理内存资源**  

不过，当父进程或者子进程在向这个内存发起写操作时，CPU 就会触发==**写保护中断**==

![[d4cfac545377b54dd035c775603b4936.webp]]

写时复制顾名思义，**在发生写操作的时候，操作系统才会去复制物理内存**，这样是为了防止 fork 创建子进程时，由于==物理内存数据的复制时间过长而导致父进程长时间阻塞的问题==

如果父进程的内存数据非常大，那自然页表也会很大，这时父进程在通过 fork 创建子进程的时候，阻塞的时间也越久  
有两个阶段会导致阻塞父进程：
1. 页表越大，阻塞的时间也越长
2. 写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长

为了主进程修改已经存在的key-value导致==主次进程数据不一致问题==，设置AOF重写缓冲区  
![[watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0ODI3Njc0,size_16,color_FFFFFF,t_70-20230309231944807.webp]]

在 bgrewriteaof 子进程执行 AOF 重写期间，主进程：
1. 执行客户端发来的命令
2. 将执行后的写命令追加到 「AOF 缓冲区」
3. 将执行后的写命令追加到 「AOF 重写缓冲区」

当子进程完成 AOF 重写工作，会向主进程发送一条信号  
主进程收到该信号后，会调用一个信号处理函数，该函数主要做以下工作：
1. 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致
2. 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件


---
# RDB快照（Redis Database）

==快照，就是记录某一个瞬间东西==  
RDB 文件的加载工作是在==服务器启动时自动执行的==  
Redis 提供了两个命令来生成 RDB 文件，分别是 
1. `save` 
2. `bgsave`  

==区别在于是否在「主线程」里执行==：
1. save：主线程生成 RDB 文件，如果写入 RDB 文件的时间太长，**会阻塞主线程**
2. bgsave：创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**

Redis 的快照是==**全量快照**==，每次执行快照，都是把内存中的「所有数据」都记录到磁盘中  
所以可以认为，执行快照是一个比较重的操作：
- 如果频率太频繁，可能会对 Redis 性能产生影响
- 如果频率太低，服务器故障时，丢失的数据会更多

这就是 RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少

## 执行快照时，数据能被修改吗？(写时复制技术)

==执行 bgsave 过程中，Redis 依然**可以继续处理操作命令**的，也就是数据是能被修改的==
### 写时复制技术（COW：Copy-On-Write）

bgsave通过fork()创建子进程
![[c34a9d1f58d602ff1fe8601f7270baa7.webp|475]]

如果主线程修改了共享数据，==**发生了写时复制后，RDB 快照保存的是原本的内存数据**==



---
# RDB 和 AOF 合体

尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：
- 如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；
- 如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销

Redis4.0提出 ==**混合使用 AOF 日志和内存快照**==，混合持久化
```
aof-use-rdb-preamble yes
```


1. 在 AOF 重写日志时，`fork` 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件
2. 主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件
3. 写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件

==AOF 文件的**前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据**==  

![[f67379b60d151262753fec3b817b8617.webp]]

这样的好处在于:
1. 重启 Redis 加载数据的时候，前半部分是 RDB 内容，这样==**加载的时候速度会很快**==
2. 加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得==**数据更少的丢失**==



---
# 如何选择

1. 如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久
2. AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低 Redis 的性能，不知道你是否可以接受