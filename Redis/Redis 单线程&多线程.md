# Redis是单线程吗？

**Redis 单线程指的是  
==「接收客户端请求-> 解析请求 ->进行数据读写等操作 -> 发生数据给客户端」==  
这个过程是由一个线程（主线程）来完成的**  
Redis 是单线程，主要是指 Redis 的==网络 IO 和键值对读写是由一个线程来完成的==

**Redis 程序并不是单线程的**，Redis 在启动的时候，是会**启动后台线程（BIO）的**： 
1. 2.6之前，启动 2 个后台线程，分别==处理关闭文件==、==AOF 刷盘==这两个任务
2. 4.0之后，新增了一个新的后台线程，用来==异步释放 Redis 内存==，也就是 lazyfree 线程，好处是不会导致 Redis 主线程卡顿
>[!tip]
>当我们要删除一个大 key 的时候，不要使用 del 命令删除，因为 del 是在主线程处理的，这样会导致 Redis 主线程卡顿，因此我们应该使用 unlink 命令来异步删除大 key

## Redis创建单独线程的原因
Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理，是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么 ==Redis 主线程就很容易发生阻塞，这样就无法处理后续的请求了==。

![[Pasted image 20250319192111.png]]
1. BIO_CLOSE_FILE，关闭文件任务队列：当队列有任务后，后台线程会调用 close(fd) ，将文件关闭；
2. BIO_AOF_FSYNC，AOF 刷盘任务队列：当 AOF 日志配置成 everysec 选项后，主线程会把 AOF 写日志操作封装成一个任务，也放到队列中。当发现队列有任务后，后台线程会调用 fsync(fd)，将 AOF 文件刷盘
3. BIO_LAZY_FREE，lazy free 任务队列：当队列有任务后，后台线程会 free(obj) 释放对象 / free(dict) 删除数据库所有对象 / free(skiplist) 释放跳表对象；


---
# Redis为什么使用单线程？
> [!tip] 我们经常会听到一种说法：使用多线程，可以增加系统吞吐率，或是可以增加系统扩展性。

但是这需要一个好的系统设计，否则会因为多线程同时访问的共享资源导致额外的开销，这就是==多线程编程模式面临的共享资源的并发访问控制问题==

![[303255dcce6d0837bf7e2440df0f8e08-20221015222944-np9bz7l.webp|275]]
![[cbd394e62219cc5a6d9ae64035e51733-20221015222944-aa9gamw.webp|400]]

1. 需要精密的设计，例如只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，==大部分线程也在等待获取访问共享资源的互斥锁，并行变串行==，系统吞吐率并没有随着线程的增加而增加
2. 采用多线程开发一般会==引入同步原语==来保护共享资源的并发访问  
这都会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。

## 官方解释

![[Pasted image 20250319194259.png|650]]
1. ==**CPU 并不是制约 Redis 性能表现的瓶颈所在**,更多情况下是受到内存大小和网络 I/O 的限制==  
2. 使用了单线程后，==可维护性高==，使用多线程模型，引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，**增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗**


---
# Redis6.0为什么引入多线程？

**在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求**，==**这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上**。==

1. Redis 6.0 对于==网络请求采用多线程来处理==，为了提高网络请求处理的并行度
2. ==**但是对于命令执行，Redis 仍然使用单线程来处理**==，所以大家不要误解Redis 有多线程同时执行命令


---
# 单线程Redis为什么那么快？

通常来说，单线程的处理能力要比多线程差很多，但是 Redis 却能使用单线程模型达到每秒数十万级别的处理能力
1. Redis 的==大部分操作在内存上完成==，再加上它采用==了高效的数据结构==
2. Redis 采用了==多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求==，实现高吞吐率  

## 基本 IO 模型与阻塞点
例如处理一个 Get 请求，需要：
1. （bind/listen）    监听客户端请求
2. （accept）         和客户端建立连接
3. （recv）           从 socket 中读取请求
4. （parse）（parse） 解析客户端发送请求
5. （get）            根据请求类型读取键值数据
6. （send）           最后给客户端返回结果，即向 socket 中写回数据 

![[e18499ab244e4428a0e60b4da6575bc9-20221015222944-p0vc0n2.webp|525]]

但是，在这里的网络 IO 操作中，有潜在的阻塞点，分别是 accept() 和 recv()。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。 
==这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。==  
不过，幸运的是，==socket 网络模型本身支持非阻塞模式==

## 非阻塞模式
![[1ccc62ab3eb2a63c4965027b4248f34a-20221015222944-o5rwflc.webp]]

针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了
虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。

这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。

到此，Linux 中的 IO 多路复用机制就要登场了

## 基于多路复用的高性能 I/O 模型

Linux 中的 IO 多路复用机制是指==一个线程处理多个 IO 流==，就是我们经常听到的 select/epoll 机制  
基于多路复用的 Redis IO 模型
![[00ff790d4f6225aaeeebba34a71d8bea-20221015222944-wgv1zv2.webp]]
Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性

---
