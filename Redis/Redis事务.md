Redis事务的本质是一组命令的集合
事务支持一次执行多个命令，一个事务中所有命令都会被序列化
相关命令：
- MULTI：开启事务
- EXEC：执行事务的所有命令
- DISCARD：取消事务，放弃执行事务块中的所有命令
- WATCH：监视一个或者多个Key，如果事务在执行前，Key就被其他命令修改，则事务中断，不会执行事务中的任何命令
- UNWATCH：取消WATCH对所有Key的监视

---
# Redis事务的实现方式
- redis中实现事务，是引入了队列
- 开启事务后，此时客户端输入的命令，就会发送给服务器并加入这个队列中
- 当遇到了"执行事务"命令后，此时就会把队列中的任务都按照顺序一次执行
- 些任务都是在redis主线程中完成的，主线程会把事务中的操作都执行完，再处理别的客户端

---
## 事务出现错误
事务可能会遇到两种类型的命令错误：
- 语法错误的时候才失败（在命令输入的时候不检查语法）
- 要执行的key数据类型不匹配：这种错误实际上是编程错误，这应该在开发阶段被测试出来，而不是生产上

redis事务在操作失败不会回滚，全部打包返回
> [!example] 什么时候需要redis的事务？
> 比如秒杀商品，商家放货5000台，实际如果让5001个人下单成功，出现超卖问题
> 把每个用户点击购买直到完全下单成功并且商家货物减少这一整个操作合成一个事务进行执行
> 以前在多线程中，是通过加锁的方式，来避免"插队"的，在redis中可以直接使用事务
> ```
> MUlTI
> GET COUNT
> 使用Lua脚本判断COUNT>0?
> EXEC


---
# WATCH
> [!info] 使用watch可以监视key在事务的multi和exec之间，set key之后，是否在外部被其他客户端修改了

> [!tip] watch的实现原理，类似于【乐观锁】
> - 乐观锁：加锁之前，就有一个心理预期，预期接下来锁冲突的概率比较低
> - 悲观锁：加锁之前，也有一个心理预期，接下来锁冲突的概率比较高

watch的原理：
- 当执行 watch key 的时候
- redis就会给这个key==安排一个版本号==
- 版本号可以理解成一个“整数”
- 每次在修改的时候，版本号就会“变大”
- 然后在执行 事务 中命令的时候
- 就会做出判定
- 判定这个key的版本号，和最初 watch 的时候
- ==记录的版本号是否一致！！！==
- 如果一致，说明当前key在事务开启到最终执行这个过程中，没有别的客户端修改，于是才能真正执行这个事务
- 如果不一致，说明key在其他客户端中改过了，因此此处就直接丢弃事务中的操作，exec返回nil(空)


---
# Redis事务支持回滚吗？

**Redis 中并没有提供回滚机制**，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来==主动放弃事务执行==，把暂存的命令队列清空，起不到回滚的效果  

DISCARD：
```c
#读取 count 的值4
127.0.0.1:6379> GET count
"1"
#开启事务
127.0.0.1:6379> MULTI 
OK
#发送事务的第一个操作，对count减1
127.0.0.1:6379> DECR count
QUEUED
#执行DISCARD命令，主动放弃事务
127.0.0.1:6379> DISCARD
OK
#再次读取a:stock的值，值没有被修改
127.0.0.1:6379> GET count
"1"
```

所以这可以看出 ==**Redis 并不一定保证原子性**==

```c
#获取name原本的值
127.0.0.1:6379> GET name
"xiaolin"
#开启事务
127.0.0.1:6379> MULTI
OK
#设置新值
127.0.0.1:6379(TX)> SET name xialincoding
QUEUED
#注意，这条命令是错误的
# expire 过期时间正确来说是数字，并不是‘10s’字符串，但是还是入队成功了
127.0.0.1:6379(TX)> EXPIRE name 10s
QUEUED
#提交事务，执行报错
#可以看到 set 执行成功，而 expire 执行错误。
127.0.0.1:6379(TX)> EXEC
1) OK
2) (error) ERR value is not an integer or out of range
#可以看到，name 还是被设置为新值了
127.0.0.1:6379> GET name
"xialincoding"
```

### 为什么Redis 不支持事务回滚？

==官方解释：==
![[redis官方解释回滚.webp]]

> [!info] 作者不支持事务回滚的原因有以下两个：
> - 他认为 Redis 事务的执行时，错误通常都是编程错误造成的，这种错误通常只会出现在开发环境中，而很少会在实际的生产环境中出现，所以他认为没有必要为 Redis 开发事务回滚功能；
> - 不支持事务回滚是因为这种复杂的功能和 Redis 追求的简单高效的设计主旨不符合。

> [!tip] 这里不支持事务回滚，指的是不支持事务运行时错误的事务回滚