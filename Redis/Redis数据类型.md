redis数据库存储的数据实际类型由==编码（encoding）==标识
开发者常见（==显式类型==）：string、hash、string、set和zset
随着 Redis 版本的更新，后面又支持了四种数据类型：
- BitMap（2.2 版新增）
- HyperLogLog（2.8 版新增）
- GEO（3.2 版新增）
- Stream（5.0 版新增）
每种显式类型都有对应的==隐式实际类型==，如embstr、raw、hashtable、ziplist、quicklist和skiplist  
Redis存储的数据是由**redisObject**结构体构成的
# redisObject
Redis存储数据不是简单粗暴地直接使用C语言原始基础数据类型，  
而是根据自身设计理念自定义存储对象（结构体）
```c
typedef struct redisObject {
    unsigned type:4;       // 对象类型（显式类型）
    unsigned encoding:4;   // 对象编码（隐式类型）
    unsigned lru:LRU_BITS; // 对象最后一次访问时间（秒）
    int refcount;          // 引用计数。0：可被垃圾回收
    void *ptr;             // 指向实际的数据存储结构
} robj;
```
### type与encoding对应关系
![[Pasted image 20250318190000.png]]
### 数据转换条件

| 序号  |  type  | encoding                                                                                                                         |
| :-: | :----: | :------------------------------------------------------------------------------------------------------------------------------- |
|  1  | string | （1）==int==：值为整型，取值[-2^63-1, 2^63-1]  <br>（2）==embstr==：值不为整型或者整型值不在上述int范围内，且值长度小于等于44个字节  <br>（3）==raw==：值超过44个字节(64-16-3-1=44) |
|  2  |  list  | Redis 3.2 版本之后，List 数据类型底层数据结构就只由==quicklist==实现了，替代了双向链表和压缩列表                                                                   |
|  3  |  hash  | （1）==ziplist==：值个数在hash-max-ziplist-entries范围内或者值长度在hash-max-ziplist-value范围内  <br>（2）==hashtable==：超过上述范围                       |
|  4  |  set   | （1）==intset==：值为整型，取值[-2^63-1, 2^63-1]  <br>（2）==hashtable==：其他情况                                                                |
|  5  |  zset  | （1）==ziplist==：值个数在zset-max-ziplist-entries范围内或者值长度在zset-max-ziplist-value范围内  <br>（2）==skiplist==：超过上述情况                        |

---
# String
## 内部实现
string的底层的数据结构主要是：**int** 和 **SDS（简单动态字符串）**  
### SDS
之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：
1. **SDS 不仅可以保存文本数据，还可以保存二进制数据**
- `SDS` 使用 `len` 属性的值而不是空字符来判断字符串是否结束
- SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 `buf[]` 数组里的数据
2. **SDS 获取字符串长度的时间复杂度是 O(1)**，SDS 结构里用 `len` 属性记录了字符串长度
3. **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**，SDS 结构里用 `len` 属性记录了字符串长度  

### 字符串对象的内部编码结构：
![[Pasted image 20250318172748.png]]


#### 1. 整数值
![[Pasted image 20250318172910.png]]
#### 2. 字符串
encoding的确定和redis版本的边界有关：
- redis 2.+ 是 32 字节
- redis 3.0-4.0 是 39 字节
- redis 5.0 是 44 字节  

`embstr`编码是专门用于保存短字符串的一种优化编码方式
![[Pasted image 20250318173026.png]]
![[Pasted image 20250318173031.png]]
可以看到`embstr`和`raw`编码都会使用`SDS`来保存值，不同之处在于：
- `embstr`会通过==一次内存分配函数==来分配一块连续的内存空间来保存`redisObject`和`SDS`
- `raw`编码会通过调用==两次内存分配函数==来分别分配两块空间来保存`redisObject`和`SDS`
## 应用场景（共享 Session 信息）
Session 来保存用户的会话(登录)状态，Session 来保存用户的会话(登录)状态，但是对于分布式系统不再适用  
==因为分布式系统每次会把请求随机分配到不同的服务器，存在需要**重复登录**的问题==
![[Session1.webp]]
需要借助 Redis 对这些 Session 信息进行统一的存储和管理：
![[Session2.webp]]

---
# List
List 列表是简单的字符串列表
## 内部实现
List 类型的底层数据结构是由==**双向链表/压缩列表**==实现的，但是在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 ==quicklist== 实现了，替代了双向链表和压缩列表
## 应用场景（消息队列）
消息队列在存取消息时，必须要满足三个需求，分别是：
1. **消息保序**（LPUSH + RPOP）
2. **处理重复的消息**（BRPOP）
3. **保证消息可靠性**（BRPOPLPUSH）
### 1. _如何满足消息保序需求？_（LPUSH + RPOP)
List 可以使用 `LPUSH + RPOP` / `RPUSH + LPOP`命令实现消息队列
![[list消息队列.webp]]
#### 问题
> [!warning] 但是这里有一个潜在的性能风险点:  
> 在生产者往 List 中写入数据时，List 并不会==主动地通知消费者有新消息写入==，如果消费者想要及时处理消息，就需要在程序中不停地调用 `RPOP` 命令  
> 所以，即使没有新消息写入List，==消费者也要不停地调用 RPOP 命令==，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失
#### BRPOP
Redis提供了 ==BRPOP== 命令  
```shell
# 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞
BLPOP key [key ...] timeout
# 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞
BRPOP key [key ...] timeout
```
==BRPOP命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据==
![[消息队列.webp]]
### _2、如何处理重复的消息？_(自行添加全局ID)
消费者要实现重复消息的判断，需要 2 个方面的要求：
1. 每个消息都有一个==全局的 ID==
2. 消费者要记录==已经处理过的消息的 ID==
但是，List不会为每个消息生成ID号，我们需要自行为每个消息生成一个全局唯一ID  
例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列
```shell
> LPUSH mq "111000102:stock:99"
(integer) 1
```
### _3、如何保证消息可靠性？_（BRPOPLPUSH)
为了留存消息，List 类型提供了 ==`BRPOPLPUSH`== 命令  
这个命令的==**作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存**==

## List 作为消息队列有什么缺陷？

**List 不支持多个消费者消费同一条消息**，【消费组】需要由==**Stream类型**==实现

---
# Hash
Hash 是一个==键值对（key - value）集合==  
value = [{field1，value1}，...{fieldN，valueN}]
## Hash/String区别
![[hash.webp]]
## 内部实现
Hash 类型的底层数据结构是由==**压缩列表/哈希表**==实现的  
**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 ==listpack== 数据结构来实现了**
## 应用场景（缓存对象/购物车）
### 缓存对象
我们以用户信息为例，它在关系型数据库中的结构是这样的:

| uid | name  | age |
| --- | ----- | --- |
| 1   | Tom   | 15  |
| 2   | Jerry | 13  |
```c
# 存储一个哈希表uid:1的键值
> HMSET uid:1 name Tom age 15
2
# 存储一个哈希表uid:2的键值
> HMSET uid:2 name Jerry age 13
2
# 获取哈希表用户id为1中所有的键值
> HGETALL uid:1
1) "name"
2) "Tom"
3) "age"
4) "15"
```
![[hash存储结构.webp]]
### 购物车
用户 id 为 key，商品 id 为 field，商品数量为 value
![[购物车.webp|500]]

涉及的命令如下：
- 添加商品：`HSET cart:{用户id} {商品id} 1`
- 添加数量：`HINCRBY cart:{用户id} {商品id} 1`
- 商品总数：`HLEN cart:{用户id}`
- 删除商品：`HDEL cart:{用户id} {商品id}`
- 获取购物车所有商品：`HGETALL cart:{用户id}`

当前仅仅是将商品ID存储到了Redis 中，在回显商品具体信息的时候，==**还需要拿着商品 id 查询一次数据库，获取完整的商品的信息**==

---
# Set
## 内部实现
Set 类型的底层数据结构是由==**哈希表/整数集合**==实现的
## 应用场景（点赞/共同关注/抽奖活动）
集合主要特征：
1. 无序
2. 不可重复
3. 支持并交差
因此 Set 类型比较适合用来数据去重和保障数据的唯一性
([Redis 常见数据类型和应用场景 | 小林coding](https://xiaolincoding.com/redis/data_struct/command.html#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4))

---
# Zset
Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值）
![[zset.webp]]
## 内部实现
Zset 类型的底层数据结构是由==**压缩列表/跳表**==实现的
在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 **==listpack==** 数据结构来实现了

## 应用场景（排行榜/电话、姓名排序）


---
# BitMap(位图)
Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过==偏移量（offset）==定位元素。BitMap通过最小的单位bit来进行`0|1`的设置，表示某个元素的值或者状态，时间复杂度为O(1)
由于 bit 是计算机中最小的单位，使用它进行储存将==非常节省空间，特别适合一些数据量大且使用**二值统计的场景**==
![[bitmap.webp]]
## 内部实现
Bitmap 本身是用 ==String 类型== 作为底层数据结构实现的一种统计二值状态的数据类型
## 应用场景（签到统计/判断用户登录态）


---
# HyperLogLog
Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于==**「统计基数」**==的数据集合类型，基数统计就是指==统计一个集合中不重复的元素个数==   
所以，简单来说 HyperLogLog ==**提供不精确的去重计数**==   
HyperLogLog 的优点是，**在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的**  
在 Redis 里面，==**每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 `2^64` 个不同元素的基数**==
## 应用场景（百万计网页UV计算）

---
# GEO
Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于**==存储地理位置信息，并对存储的信息进行操作==**
## 内部实现
GEO 本身并没有设计新的底层数据结构，而是直接使用了 ==Sorted Set== 集合类型  
GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。

这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求
## 应用场景（叫车）

---
# Stream
Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息==队列设计==的数据类型
在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：
- 发布订阅模式，==不能持久化==也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；
- List 实现消息队列的方式==不能重复消费==，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID
## 应用场景（消息队列）
生产者通过 ==XADD== 命令插入一条消息：
```c
> XADD mymq * name xiaolin
"1654254953808-0"
```
插入成功后会返回全局唯一的 ID："1654254953808-0"  

消息的全局唯一 ID 由两部分组成：
1. 第一部分`"1654254953808"`是数据插入时，以毫秒为单位计算的==当前服务器时间==；
2. 第二部分表示插入消息在当前毫秒内的==消息序号==，这是从 0 开始编号的。例如，“1654254953808-0”就表示在“1654254953808”毫秒内的第 1 条消息

如果==**想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项**==，实现类似于 BRPOP 的阻塞读取操作
![[Stream简易.webp]]
### Stream比List特有的功能
Stream 可以以使用 ==**XGROUP 创建消费组**==
创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取:  
```c
#创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。
> XGROUP CREATE mymq group1 0-0
OK
# 创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。
> XGROUP CREATE mymq group2 0-0
OK
```
消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令:  
```c
# 命令最后的参数“>”，表示从第一条尚未被消费的消息开始读取。
> XREADGROUP GROUP group1 consumer1 STREAMS mymq >
1) 1) "mymq"
   2) 1) 1) "1654254953808-0"
         2) 1) "name"
            2) "xiaolin"
```
==**消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息**==  
我们执行完刚才的 XREADGROUP 命令后，再执行一次同样的命令，此时读到的就是空值了：
```c
> XREADGROUP GROUP group1 consumer1 STREAMS mymq >
(nil)
```

### 基于Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？
Streams 会自动使用==内部队列（也称为 PENDING List）==留存消费组里每个消费者读取的消息，直到消费者使用 ==XACK== 命令通知 Streams“消息已经处理完成”
![[消息确认.webp]]
1. 如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，==消息仍然会留存==。
2. 此时，**消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息**
### Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？
一个专业的消息队列，必须要做到两大块：
- 消息不丢。
- 消息可堆积
#### 1. _Redis Stream 消息会丢失吗？（会）_
使用一个消息队列，其实就分为三大块：==**生产者、队列中间件、消费者**==，所以要保证消息就是保证三个环节都不能丢失数据
![[消息队列三个阶段.webp]]
1. ==生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理==。 从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 （ MQ 中间件） 的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的
2. ==消费者不会丢消息==，因为 Stream （ MQ 中间件）会自动使用==内部队列==（也称为 PENDING List）留存消费组里每个消费者读取的消息，但是==未被确认的消息==。消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。等到消费者执行完业务逻辑后，再发送消费确认 XACK 命令，也能保证消息的不丢失。
3. ==中间件会丢消息==，Redis 在以下 2 个场景下，都会导致数据丢失：
- AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能
- 主从复制也是异步的，[主从切换时，也存在丢失数据的可能](https://xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1)
> 可以看到，Redis 在队列中间件环节无法保证消息不丢。像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是==部署一个集群==，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失

#### _2、Redis Stream 消息可堆积吗？_
Redis 的数据都存储在==内存==中，这就意味着一旦发生==消息积压==，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 ==**OOM**( **Out of Memory** 的缩写，表示系统可用内存不足，导致操作无法继续进行)== 的风险。  
==所以 Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生==

- 当指定队列最大长度时，队列长度超过上限后，==旧消息会被删除==，只保留固定长度的新消息
- 但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在==磁盘上==，当消息积压时，无非就是多占用一些磁盘空间

因此，把 Redis 当作队列来使用时，会面临的 2 个问题：
- ==Redis 本身可能会丢数据==；
- ==面对消息挤压，内存资源会紧张==；

所以，能不能将 Redis 作为消息队列来使用，关键看你的业务场景：
- 如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。
- 如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧

#### Redis 发布/订阅机制为什么不可以作为消息队列？
发布订阅机制存在以下==缺点==，都是跟丢失数据有关：

1. 发布/订阅机制没有基于任何数据类型实现，所以==不具备「数据持久化」==的能力，也就是发布/订阅机制的相关操作，==不会写入到 RDB 和 AOF 中==，当 Redis 宕机重启，发布/订阅机制的数据也会全部丢失。
2. 发布订阅模式是“==发后既忘==”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。
3. 当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 `client-output-buffer-limit pubsub 32mb 8mb 60`。

所以，发布/订阅机制只适合即时通讯的场景，比如[构建哨兵集群 (opens new window)](https://xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84)的场景采用了发布/订阅机制。