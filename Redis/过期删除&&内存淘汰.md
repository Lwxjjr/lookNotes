Redis 的「内存淘汰策略」和「过期删除策略」  
这两个机制虽然都是做删除的操作，但是==触发的条件和使用的策略都是不同的==  

# 过期删除策略

Redis 是可以对 key 设置过期时间的，因此需要有相应的机制将已过期的键值对删除

## 如何设置过期时间

设置key过期的命令：
```shell
1. expire key seconds（秒）
2. pexpire key milliseconds（毫秒）
3. expireat key seconds-timestamp（时间戳精确到秒）
4. pexpireat key milliseconds-timestamp（时间戳精确的毫秒）
```


在设置字符串时，也可以同时对 key 设置过期时间：
```shell
1. set key value ex seconds（秒）
2. set key value px seconds（毫秒）
3. setex key seconds value （秒）
```

查看key剩余的存活时间：ttl key
取消 key 的过期时间: persist key

## 如何判定 key 已过期了？

==**过期字典**（expires dict）保存key+过期时间==  
过期字典存储在 redisDb 结构中  
```c
typedef struct redisDb {
    dict *dict;     // 数据库键空间，存放着所有的键值对 
    dict *expires;  // 键的过期时间 
    ....
} redisDb;
```

![[过期字典数据结构.webp]]

==字典实际上是哈希表==，哈希表的最大好处就是让我们可以用 O(1) 的时间复杂度来快速查找  
![[过期判断流程.webp|400]]

## 过期删除策略有哪些？

- 定时删除；
- 惰性删除；
- 定期删除；

### 定时删除

==**在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作**==

#### 优点：
可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放，==对内存是最友好的==
#### 缺点：
在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，==定时删除策略对 CPU 不友好==。

---
### 惰性删除

==**不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key**==

#### 优点：
因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略==对 CPU 时间最友好==
#### 缺点：
如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，==惰性删除策略对内存不友好==

---
### 定期删除
==**每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key**==
#### 优点：
1. 通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响
2. 也能删除一部分过期的数据减少了过期键对空间的无效占用
#### 缺点：
1. 内存清理方面没有定时删除效果好
2. 没有惰性删除使用的系统资源少
3. 难以把握删除操作执行的时长和频率，执行太频繁 -> 定时删除，不频繁 -> 惰性删除

## Redis过期删除策略是什么？（惰性删除+定期删除）
### 惰性删除策略 `expireIfNeeded`
```c
int expireIfNeeded(redisDb *db, robj *key) {
    // 判断 key 是否过期
    if (!keyIsExpired(db,key)) return 0;
    ....
    /* 删除过期键 */
    ....
    // 如果 server.lazyfree_lazy_expire 为 1 表示异步删除，反之同步删除；
    return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :
                                         dbSyncDelete(db,key);
}
```
检查 key 是否过期：
- 如果过期，则删除该 key，至于选择异步删除，还是选择同步删除，根据 `lazyfree_lazy_expire` 参数配置决定（Redis 4.0版本开始提供参数），然后返回 null 客户端；
- 如果没有过期，不做任何处理，然后返回正常的键值对给客户端；
![[惰性删除.webp|450]]

---
### 定期删除
==每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key==
#### _1、这个间隔检查的时间是多长呢？_
==redis.conf配置hz==（默认每秒进行10次过期检查）
从数据库中随机抽取一定数量的 key 进行过期检查，而不是过期数据库遍历所有key
#### _2、随机抽查的数量是多少呢？_
期删除的实现在 expire.c 文件下的 `activeExpireCycle`  
其中随机抽查的数量由 `ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP` 定义的，==固定为 20==  
==数据库每轮抽查时，会随机选择 20 个 key 判断是否过期==  
定期删除是一个==循环的流程==：
1. 从过期字典中随机抽取 20 个 key；
2. 检查这 20 个 key 是否过期，并删除已过期的 key；
3. 如果本轮检查的已过期 key 的数量，超过 5 个（20/4），也就是「已过期 key 的数量」占比「随机抽取 key 的数量」大于 25%，则继续重复步骤 1；如果已过期的 key 比例小于 25%，则停止继续删除过期 key，然后等待下一轮再检查。

那 Redis ==为了保证定期删除不会出现循环过度，导致线程卡死现象==，为此增加了定期删除循环流程的时间上限，默认不会超过 25ms

![[定时删除流程.webp|500]]



## Redis 持久化时，对过期键会如何处理的？

RDB 文件分为两个阶段：
1. **RDB 文件生成阶段**：从内存状态持久化成 RDB（文件）的时候，会对 key 进行过期检查，==**过期的键「不会」被保存到新的 RDB 文件中**==
2. **RDB 加载阶段**：
- **如果 Redis 是「主服务器」运行模式的话，在载入 RDB 文件时，程序会对文件中保存的键进行检查，过期键「不会」被载入到数据库中**
- **如果 Redis 是「从服务器」运行模式的话，在载入 RDB 文件时，不论键是否过期都会被载入到数据库中**


AOF 文件分为两个阶段：
1. **AOF 文件写入阶段**：**如果数据库某个过期键还没被删除，那么 AOF 文件会保留此过期键，当此过期键被删除后，Redis 会向 AOF 文件追加一条 DEL 命令来显式地删除该键值**
2. **AOF 重写阶段**：对 Redis 中的键值对进行检查，**已过期的键不会被保存到重写后的 AOF 文件中**


## Redis 主从模式中，对过期键会如何处理？

从库不会进行过期扫描，从库对过期的处理是==**被动的**==  
从库的过期键处理依靠主服务器控制，==**主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库**==


---
# 内存淘汰策略

过期删除策略，是删除已过期的 key  
Redis 的运行内存 > Redis 设置的最大内存之后，使用内存淘汰策略删除符合条件的 key

## 如何设置 Redis 最大运行内存？

==redis.conf 中 `maxmemory <bytes>`来设定最大运行内存==  
不同位数的操作系统，maxmemory默认值不同
- 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。
- 在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃

## Redis 内存淘汰策略有哪些？
Redis 内存淘汰策略共有八种  
这八种策略大体分为==「不进行数据淘汰」==和==「进行数据淘汰」==两类策略
### _1、不进行数据淘汰的策略_
==**noeviction**（Redis3.0之后，默认的内存淘汰策略）==
它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，会报错通知禁止写入，不淘汰任何数据
### _2、进行数据淘汰的策略_
#### （1）在设置了过期时间的数据中进行淘汰：
- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值。
- **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；
#### （2）在所有数据范围内进行淘汰：
- **allkeys-random**：随机淘汰任意键值;
- **allkeys-lru**：淘汰整个键值中最久未使用的键值；
- **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值。

## 如何查看当前 Redis 使用的内存淘汰策略？
==config get maxmemory-policy==
```
127.0.0.1:6379> config get maxmemory-policy
1) "maxmemory-policy"
2) "noeviction"
```

## LRU 算法和 LFU 算法有什么区别？
**LRU**（Least Recently Used）翻译为==**最近最少使用**==  
**LFU**（Least Frequently Used） 翻译为==**最近最不常用**==
### LRU（Least Recently Used）最近最少使用
传统LRU使用基于「链表」记录访问数据，最新操作的键会被移动到表头，需要内存淘汰时，只需要删除链表尾部的元素即可
问题：
1. 需要用链表管理所有的缓存数据，这会带来==额外的空间开销==；
2. 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，就会带来==很多链表移动操作，会很耗时==，进而会降低 Redis 缓存性能

#### Redis如何实现LRU?（近似LRU）
Redis 实现的是一种**近似 LRU 算法**，目的是为了更好的节约内存  
==**在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间**==  
当 Redis 进行内存淘汰时，会使用==**随机采样的方式来淘汰数据**==，它是随机取 5 个值（此值可配置），然后**淘汰最久没有使用的那个**

优点：
1. 不用为所有的数据维护一个大链表，节省了空间占用
2. 不用在每次数据访问时都移动链表项，提升了缓存的性能  

> [!question] ==**无法解决缓存污染问题**==  
> 缓存污染通常发生在一次性或低频率的数据占据缓存空间，导致高频率数据被替换  
> 比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染

因此Redis4.0引入LFU算法解决这个问题

---
### LFU（Least Frequently Used）最近最不常用
LFU 算法是根据数据访问次数来淘汰数据的  
它的核心思想是==“如果数据过去被访问多次，那么将来被访问的频率也更高”==  

LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数，这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题、

#### Redis如何实现LFU?（近似LFU）
LFU 算法相比于 LRU 算法的实现，==多记录了「数据的访问频次」的信息==
```c
typedef struct redisObject {
    ...
    // 24 bits，用于记录对象的访问信息
    unsigned lru:24;  
    ...
} robj;
```

Redis 对象头中的 ==lru 字段==，在 LRU 算法下和 LFU 算法下使用方式并不相同  
- LRU：Redis 对象头的 24 bits 的 lru 字段是用来记录 ==key 的访问时间戳==，根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key  
- LFU：Redis对象头的 24 bits 的 lru 字段被分成两段来存储，==高 16bit 存储 ldt(Last Decrement Time)==，==低 8bit 存储 logc(Logistic Counter)==

![[lru字段.webp|700]]
- ldt 是用来记录 ==key 的访问时间戳==；
- logc 是用来记录 ==key 的访问频次==，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。  
==**logc 会随时间推移而衰减的**。==
在每次 key 被访问时，会先对 logc 做一个衰减操作，衰减的值跟前后访问时间的差距有关系，如果上一次访问的时间与这一次访问的时间差距很大，那么衰减的值就越大，这样实现的 LFU 算法是根据==**访问频率**来淘汰数据的==  
对 logc 做完衰减操作后，就开始对 logc 进行增加操作，增加操作并不是单纯的 + 1，而是根据概率增加，如果 logc 越大的 key，它的 logc 就越难再增加。  

所以，Redis 在访问 key 时，对于 logc 是这样变化的：
1. 先按照上次访问距离当前的时长，来对 logc 进行衰减；
2. 然后，再按照一定概率增加 logc 的值

---
# 总结：
Redis 使用的过期删除策略是==「惰性删除+定期删除」==，==删除的对象是已过期的 key==

![[过期删除策略.webp]]

内存淘汰策略是解决内存过大的问题，当 Redis 的运行内存超过最大运行内存时，就会触发内存淘汰策略，Redis 4.0 之后共实现了 8 种内存淘汰策略，我也对这 8 种的策略进行分类，如下：

![[内存淘汰策略.webp]]