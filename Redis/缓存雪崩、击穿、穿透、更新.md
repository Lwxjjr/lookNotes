当用户的请求，都访问数据库的话，请求数量一上来，数据库很容易就奔溃的了，所以为了避免用户直接访问数据库，会用 Redis 作为缓存层

![[37e4378d2edcb5e217b00e5f12973efd-20230309232858764.webp|277]]

引入了缓存层，就会有缓存异常的三个问题，分别是：
- **缓存雪崩**
- **缓存击穿**
- **缓存穿透**

# 缓存雪崩

我们为了==保证缓存中的数据与数据库中的数据一致性==，会给 Redis 里的数据设置过期时间，当缓存数据过期后，用户访问的数据如果不在缓存里，业务系统需要重新生成缓存，因此就会访问数据库，并将数据更新到 Redis 里，这样后续请求都可以直接命中缓存。

![[e2b8d2eb5536aa71664772457792ec40-20230309232851699.webp]]

那么，当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃，这就是**缓存雪崩**的问题

![[717343a0da7a1b05edab1d1cdf8f28e5.webp]]
可以看到，发生缓存雪崩有两个原因：
- ==大量数据同时过期；==
- ==Redis 故障宕机；==

## 大数据同时过期

应对方法：
1. 均匀设置过期时间；
2. 互斥锁；
3. 后台更新缓存；
### _1. 均匀设置过期时间_
**==给缓存数据的过期时间加上一个随机数==**，这样就保证数据不会在同一时间过期
### _2. 互斥锁_
当业务线程在处理用户请求时，==**如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存**==（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁
实现互斥锁的时候，最好设置==**超时时间**==，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现==无响应的现象==。
### _3. 后台更新缓存_
1. 业务线程不再负责更新缓存
2. 缓存也不设置有效期  
==**让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新 **==  

缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为**当系统内存紧张的时候，有些缓存数据会被“淘汰”**

1. 后台线程不仅负责定时更新缓存，而且也负责**频繁地检测缓存是否有效**，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存
2. 在业务线程发现缓存数据失效后（缓存数据被淘汰），**通过消息队列发送一条消息通知后台线程更新缓存**，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好

> [!tip] 在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的==**缓存预热**==，后台更新缓存的机制刚好也适合干这个事情。




---
## Redis故障宕机

应对方法：
1. 服务熔断或请求限流机制
2. 构建 Redis 缓存高可靠集群
### _1. 服务熔断 + 请求限流机制_

**服务熔断**机制，==**暂停业务应用对缓存服务的访问，直接返回错误**==，不用再继续访问数据库，直到Reis恢复正常  
为了减少对业务的影响，我们可以启用==**请求限流**机制==，**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，防止全部业务都无法正常工作
### _2. 主从节点构建 Redis 缓存高可靠集群_
服务熔断或请求限流机制是==缓存雪崩发生后的应对方案==  
我们最好通过**主从节点的方式构建 Redis 缓存高可靠集群**
如果 Redis 缓存的主节点故障宕机，==从节点可以切换成为主节点==，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题



---
## 缓存击穿

==热点数据==：被频地访问的数据
如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，==直接访问数据库，数据库很容易就被高并发的请求冲垮==

![[acb5f4e7ef24a524a53c39eb016f63d4-20230309232840753.webp|500]]

可以认为缓存击穿是缓存雪崩的一个子集
应对方案：
1. 互斥锁方案
2. 不给热点数据设置过期时间


---
# 缓存穿透

发生缓存雪崩或击穿时，数据库中还是保存了应用要访问的数据，一旦缓存恢复相对应的数据，就可以减轻数据库的压力  
**==缓存穿透==**：当用户访问的数据，**既不在缓存中，也不在数据库中**
### 发生情况
1. ==业务误操作==，缓存中的数据和数据库中的数据都被误删除了
2. ==黑客恶意攻击==，故意大量访问某些读取不存在数据的业务
### 应对方案
#### _1. 非法请求的限制_
在 API 入口处要判断：
1. 求请求参数是否合理
2. 请求参数是否含有非法值
3. 请求字段是否存在  

如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库
#### _2.缓存空值/默认值_
可以针对查询的数据，==在缓存中设置一个空值或者默认值==，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库
#### _3.使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在_
##### 布隆过滤器
布隆过滤器组成：
- 初始值都为 0 的位图数组
- N 个哈希函数
当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，==如果查询到数据没有被标记，说明不在数据库中==  

布隆过滤器会通过 3 个操作完成标记：
1. 使用 N 个哈希函数分别对数据做==哈希计算==，得到 N 个哈希值
2. 将第一步得到的 N 个哈希值对位图数组的长度==取模==，得到每个哈希值==在位图数组的对应位置==
3. 将每个哈希值在位图数组的==对应位置的值设置为 1==

![[86b0046c2622b2c4bda697f9bc0f5b28.webp|650]]

布隆过滤器由于是基于哈希函数实现查找的，==**存在哈希冲突的可能性**==  
所以，==**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**==



---
# 总结

![[061e2c04e0ebca3425dd75dd035b6b7b.webp]]



---
# 缓存更新

常见更新策略：
1. Cache Aside（旁路缓存）
2. Read/Write Through（读穿/写穿）
3. Write Back（写回）

实际开发中，Redis 和 MySQL 的更新策略用的是 ==Cache Aside==，另外两种策略应用不了

## Cache Aisde（旁路缓存）

==应用程序直接与「数据库、缓存」交互，并负责对缓存的维护==  
该策略又可以细分为「读策略」和「写策略」  

![[6e3db3ba2f829ddc14237f5c7c00e7ce-20230309232338149.webp|450]]  
写策略：
- 先更新数据库中的数据，再删除缓存中的数据。  

读策略的步骤：
- 如果读取的数据命中了缓存，则直接返回数据；
- 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户

==**不能先删除缓存再更新数据库**==
原因是在「读+写」并发的时候，会出现缓存和数据库的==数据不一致性==的问题

==**Cache Aside 策略适合读多写少的场景，不适合写多的场景**==   
因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：
1. 在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了
2. 在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受

## Read/Write Through（读穿 / 写穿）

==应用程序只和缓存交互，不再和数据库交互，而是由缓存和数据库交互，相当于更新数据库的操作由缓存自己代理了==

在我们开发过程中相比 Cache Aside 策略要少见一些，原因是我们经常使用的分布式缓存组件，==无论是 Memcached 还是 Redis 都不提供写入数据库和自动加载数据库中的数据的功能==

![[WriteThrough.webp]]


## Write Back（写回）

==在更新数据的时候，只更新缓存，同时将缓存数据设置为脏的，然后立马返回，并不会更新数据库。对于数据库的更新，会通过批量异步更新的方式进行==
Write Back（写回）策略也不能应用到我们常用的数据库和缓存的场景中，==因为 Redis 并没有异步更新数据库的功能==