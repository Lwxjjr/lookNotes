# 认证和授权的区别
简单来说：
- **认证 (Authentication)：** 你是谁。
- **授权 (Authorization)：** 你有权限干什么

稍微正式点（啰嗦点）的说法就是：
- **Authentication（认证）** 是验证您的身份的凭据（例如用户名/用户 ID 和密码），通过这个凭据，系统得以知道你就是你，也就是说系统存在你这个用户。所以，Authentication 被称为身份/用户验证。
- **Authorization（授权）** 发生在 **Authentication（认证）** 之后。授权嘛，光看意思大家应该就明白，它主要掌管我们访问系统的权限。比如有些特定资源只能具有特定权限的人才能访问比如 admin，有些对系统资源操作比如删除、添加、更新只能特定人才具有

---
# Cookie 和 Session
HTTP协议是一种==无状态协议==，即每次服务端接收到客户端的请求时，都是一种全新的请求，服务端并不知道客户端的历史请求记录
==一句有意思的话来描述就是人生只如初见，对服务器来说，每次的请求都是全新的==
而状态可以理解为客户端和服务器在某次会话中产生的数据

==Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性==

## Session
客户端请求服务端，服务端会为这次请求开辟一块`内存空间`，这个对象便是 Session 对象，存储结构为 `ConcurrentHashMap`
`Session` 的主要作用就是通过服务端记录用户的状态，典型场景是购物车，服务端给特定的用户创建特定的`Session`后就可以标识这个用户并且跟踪这个用户

## Cookie
### Cookie是什么
在 Internet 中，Cookie 实际上是指小量信息，是由 **Web 服务器创建的，将信息存储在用户计算机上（客户端）的数据文件**

### Cookie的机制
Cookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）
Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等

> [!info] Cookie 的特点
> 1. 浏览器发送请求的时候，自动把携带该站点之前存储的Cookie信息
> 2. 服务端可以设置Cookie数据
> 3. Cookie是针对单个域名的，不同域名之间的Cookie是独立的
> 4. Cookie数据可以配置过期时间，过期的Cookie数据会被系统清除

HTTP 协议中的 Cookie 包括 `Web Cookie` 和`浏览器 Cookie`，它是服务器发送到 Web 浏览器的一小块数据
服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器
通常，它用于判断两个请求是否来自于同一个浏览器，例如用户保持登录状态
Cookie 主要用于下面三个目的
- `会话管理`，如登陆、购物车、游戏得分或者服务器应该记住的其他内容
- `个性化`，如用户偏好、主题或者其他设置
- `追踪`，如记录和分析用户行为

> [!tip] 
> 1. 创建Cookie：Session Cookies当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 `Set-Cookie` 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求
> 2. Set-Cookie：HTTP响应头将cookie从服务器发送到用户代理，通过Set-Cookie告诉客户端需要存储Cookie。之后随着对服务器的每个新请求，浏览器将使用Cookie头将以前存储的Cookie发送给服务器

### Cookie分类
- `Session Cookie`（会话Cookie）：==不包含到期日期，存储在内存，特征是客户端关闭时Cookie会删除==，因为它没有指定`Expires`或`Max-Age`指令。但是，Web 浏览器可能会使用会话还原，这会使大多数会话 Cookie 保持永久状态，就像从未关闭过浏览器一样
- `Persistent Cookie`（永久Cookie）：通过指定`Expires`或`Max-Age`指令设定过期，到达指定日期后，==Cookie将从磁盘中删除==
- Cookie 的 Secure 和 HttpOnly 标记：
	- 安全的Cookie需要经过 HTTPS 协议通过加密的方式发送到服务器。即使是安全的，也不应该将敏感信息存储在cookie 中，因为它们本质上是不安全的，并且此标志不能提供真正的保护。

### Cookie作用域
`Domain` 和 `Path` 标识定义了 Cookie 的作用域：即 Cookie 应该发送给哪些 URL
`Domain`：标识了==哪些主机可以接收Cookie==。如果不指定，默认为当前主机(不包含子域名）。如果指定了`Domain`，则一般包含子域名。
> [!example]
  例如，如果设置 `Domain=mozilla.org`，则 Cookie 也包含在子域名中（如`developer.mozilla.org`）。
  例如，设置 `Path=/docs`，则以下地址都会匹配
  `/docs`   `/docs/Web/`  `/docs/Web/HTTP`

## Session/Cookie/Token区别
- session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session，依赖cookie
- cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加
- token也类似一个令牌，无状态，用户信息都被加密到token中，服务器收到token后解密就可知道是哪个用户，需要开发者手动添加

## 使用Session-Cookie进行身份验证
很多时候我们都是通过 `SessionID` 来实现特定的用户，`SessionID` 一般会选择存放在 Redis 中
1. 用户成功登陆系统，然后返回给客户端具有 `SessionID` 的 `Cookie` 
2. 当用户向后端发起请求的时候会把 `SessionID` 带上，这样后端就知道你的身份状态了

![[Pasted image 20250507105254.png]]


![[Pasted image 20250507111429.png]]

> [!tip] 注意事项
> 1. 依赖 `Session` 的关键业务一定要确保客户端开启了 `Cookie`
> 2. 注意 `Session` 的过期时间

> [!question] 没有Cookie的话Session还能用吗
> 一般是通过 `Cookie` 来保存 `SessionID` ，假如你使用了 `Cookie` 保存 `SessionID` 的方案的话， 如果客户端禁用了 `Cookie`，那么 `Session` 就无法正常工作
> 但是，可以将 `SessionID` 放在请求的 `url` 里面`https://javaguide.cn/?Session_id=xxx` 。这种方案的话可行，但是安全性和用户体验感降低。当然，为了安全你也可以对 `SessionID` 进行一次加密之后再传入后端
---


---
# Token
令牌，是用户身份的验证方法
最简单的token组成：uid（用户唯一身份标识）、time（当前时间戳）、sign（签名）

---
# JWT
JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制，JWT是无状态的令牌，不需要在服务器端存储会话信息
JWT和Session Cookie都是==**用来处理在不同页面之间切换，保存用户登录信息的机制**==
JWT自身包含了身份验证所需要的所有消息，所以我们的服务器不需要存储Sesssion消息
JWT主要用来以下两点：
1. `认证(Authorization)`：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。
2. `信息交换(Information Exchange)`：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 `head` 和 `payload` 计算的，因此你还可以验证内容是否遭到篡改

## JWT组成
JWT本质上就是一组字串，通过（`.`）切分为3个部分：
- Header：标头，==描述了JWT元数据，签名算法和Token类型==
- Payload：载荷，==用来存储实际需要传递的数据==，包含Claims（声明）：
	- `Registered Claims（注册声明）`：
		- iss (issuer)：签发人
		- exp (expiration time)：过期时间
		- sub (subject)：主题
		- aud (audience)：受众
		- nbf (Not Before)：生效时间
		- iat (Issued At)：签发时间
		- jti (JWT ID)：编号
	- `Public Claims（公有声明）`：JWT 签发方可以自定义的声明
	- `Private Claims（私有声明）`：JWT 签发方因为项目需要而自定义的声明，更符合实际项目场景使用
- Signature：签名，==防止JWT（主要是Payload）被篡改==，这个签名的生成需要用到：
	- Header + Payload
	- 存放在服务端的密钥(一定不要泄露出去)
	- 签名算法

## JWT缺点
JWT 一旦派发出去，在失效之前都是有效的，没办法即使撤销JWT
得在业务层增加判断逻辑
Eg：黑名单机制。使用内存数据库维护一个黑名单

## JWT身份验证
服务器通过 Payload、Header 和 Secret(密钥)创建 JWT 并将 JWT 发送给客户端。==客户端接收到 JWT 之后，会将其保存在 Cookie 或者 localStorage 里面==，以后客户端发出的所有请求都会携带这个令牌。

![[Pasted image 20250507114744.png]]

两点建议：
1. 建议将 JWT 存放在 localStorage 中，放在 Cookie 中会有 CSRF 风险。
2. 请求服务端并携带 JWT 的常见做法是将其放在 HTTP Header 的 `Authorization` 字段中（`Authorization: Bearer Token`）。

> [!error] CSRF攻击
> **CSRF(Cross Site Request Forgery)** 一般被翻译为 **跨站请求伪造**
> 简单来说：就是利用你的身份发送一些不好的请求
> 因为我们进行`session`认证时，常使用`cookie`来存储`sessionID`，每次请求都会来上这个`sessionID`，服务端通过`sessionID`来标识，如果别人通过`cookie`拿到了`sessionID`就可以代替你身份来访问系统了
> 
> `Token`：我们一般登录成功后拿到`token`，会选择存放在 `localStorage` （浏览器本地存储）中。前端通过某些方式给每个发送到后端的请求加上这个token，即使点击了非法链接发送请求到了服务端，这个非法请求也不会携带token



