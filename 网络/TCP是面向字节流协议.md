TCP 是面向字节流的协议，UDP 是面向报文的协议  
操作系统对 TCP 和 UDP 协议的==**发送方的机制不同**==  
## UDP是面向报文的协议
当用户消息通过 UDP 协议传输时，==**操作系统不会对消息进行拆分**==  
发出去的 UDP 报文中的数据部分就是完整的用户消息

收到了两个 UDP 报文，操作系统是怎么区分开的  
![[a9116c5b375d356048df033dcb53582e.webp|575]]


---
## TCP是面向字节流的协议
当用户消息通过 TCP 协议传输时，==**消息可能会被操作系统分组成多个的 TCP 报文**==  
在发送端，当我们调用 send 函数完成数据"发送"以后，数据并没有被真正从网络上发送出去，==只是从应用程序拷贝到了操作系统内核协议栈中==  
至于什么时候真正被发送，==**取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件**==  

我们==不能认为一个用户消息对应一个 TCP 报文==  
正因为这样，所以 TCP 是面向字节流的协议  

当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的==TCP 粘包问题==  

### 如何解决粘包问题
粘包的问题出现是==**因为不知道一个用户消息的边界在哪**==
一般有三种方式分包的方式：
- 固定长度的消息；
- 特殊字符作为边界；
- 自定义消息结构。

#### 固定长度的消息
每个用户消息都是固定长度的，接收方接满固定长度的字节，就认为该内容是一个完整有效的消息  
灵活度不高，实际很少用  
#### 特殊字符作为边界
2个消息之间插入特殊字符串，接收到后就认为读完一个完整的消息  
作为特殊字符，如果消息内有这个字符串，我们要对这个字符转义   
#### 自定义消息结构
自定义消息结构，由包头 + 数据组成   
```go
struct { 
    u_int32_t message_length; 
    char message_data[]; 
} message;
```
接收方接受包头大小后，解析包头内容 --> 数据长度 + 数据