## API
1. REST架构风格
2. GraphQL

## REST
> [!info] REST是一种架构风格
> **RE**presentational：资源的代表性
> **S**tate **T**ransfer：状态传输
### REST的6大约束：
- **客户端-服务端**：双端各自独立，分离用户界面和数据存储这2个关注点，各自使用不同的技术栈
- **无状态**：服务端无法保存客户端的上下文执行环节，从客户端发起的请求需要包含服务端所必要的信息
- **统一接口**：用一套标准方式进行交互（URI, HTTP Verbs, HATEOAS）
- **缓存**：无状态不代表不缓存，可以显示的标记为可缓存，服务器在返回数据时，给信息**贴上“保质期”标签**，后续用户再次发起同样的请求，浏览器会直接从自己的缓存里面取
- **分层系统**：客户端不知道自己连接的是中间层还是最后的服务器，这样可以提高系统的可伸缩性和安全性
- **按需代码**：服务器可向客户端发送可执行代码

### REST的问题：
1. **过度获取 (Over-fetching)**：客户端只需要资源的一小部分信息，但 API 返回了该资源的全部信息。
2. **获取不足 (Under-fetching) & “聊天式”交互 (Chatty API)**：客户端需要的信息分散在多个资源中，导致需要发起多次请求才能凑齐所有数据。
---
## GraphQL
> [!example] 想象一下去餐厅点餐
> ### RESTAPI就像是标准点餐
> 比如“A套餐（牛排+沙拉+薯条）”、“B套餐（意面+面包）”
> 1. **问题一（过度获取 Over-fetching）**：你今天只想吃一块牛排，但你必须点整个“A套餐”
> 2. **问题二（获取不足 Under-fetching）**：你想吃牛排，还想喝一份“C套餐”里的汤。你需要和服务员（服务器）沟通两次。
> 
> REST API 就是这样，每个“套餐”就是一个**固定的 API 地址（Endpoint）**，比如 /api/posts/123，它返回的数据结构是后端定死的，不管你要不要，全都给你。如果需要的数据在别的地方，你就得再请求另一个地址
> ### GraphQL就像是私人定制的自助餐
> 大厨（服务器）会完全按照你的要求，把你点的东西精准地放在一个盘子里
> GraphQL 就是这样，**它只有一个“总服务台”（一个唯一的 Endpoint）**，比如 /graphql），你想获取什么数据，就写一张详细的“点菜单”（Query），一次性发给服务器。服务器会严格按照你的菜单，不多不少地把数据返回给你。

## RPC
> [!info] **Remote Procedure Call**：远程过程调用
  允许运行于一台计算机的程序调用另一台计算机的子程序 
  程序员无需额外地为这个交互作用编程
  RPC 的目标是让**分布式计算（程序分布在不同计算机上）变得像单机计算一样简单**，对程序员隐藏底层网络通信的复杂性。

一个完整的RPC调用过程：
1. 客户端调用
2. RPC提供`stub`给客户端，这是一个存在于客户端本地的**代理对象**，**它的职责**：将方法名和参数进行打包和编码（**编组 (Marshalling)** 或 **序列化 (Serialization)**）通过网络发送给服务器
3. RPC运行时库：这是一个处理网络通信的底层库，在客户端和服务器端都存在
4. 服务端存根接收到数据包后，进行解码和解包，解析出要调用的方法名和参数，它会根据解析出的信息，去调用服务器上真正的业务逻辑实现
5. 服务器调用
6. 返回过程

> [!example] 打电话
> ### 原始的网络通信（像写信）
> 1. 你（客户端）需要知道朋友的地址（IP 和端口）。
> 2. 你用他能看懂的语言（约定的数据格式，如 JSON）写一封信，详细说明要办什么事。
> 3. 你把信装进信封（打包成 TCP/IP 数据包），贴上邮票，投进邮筒（通过网络发送）。
> 4. 邮局系统（网络协议栈）负责把信送到朋友家。
> 5. 朋友（服务器）收到信，拆开，阅读，理解你的请求。
> 6. 他办完事，再写一封回信，重复上述过程寄回给你。  
> 
> **痛点**：这个过程非常繁琐，每一步你都要亲力亲为，而且容易出错（信写错了，地址填错了等）。
> ### RPC（像打电话）
> 现在你不想写信了，你决定雇一个**“私人助理”**，这个助理就是 **RPC 框架**。它知道老王的电话号码（从配置中读取服务地址），- 他把你的指令“calculate, 2, 3”转换成电话线能传输的“暗号”（**序列化/编码**）。他负责拨号、等待接通、发送暗号（处理网络连接和数据传输）
