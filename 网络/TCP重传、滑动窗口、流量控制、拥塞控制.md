> [!tip]
> **swnd（Send Window）**
> **rwnd（Receive Window)**
> **cwnd（Congestion Window）**
> **ssthresh（Slow Start Threshold）**
# 重传机制
TCP实现可靠传输的方式之一，是通过序列号和确认应答号  
在错综复杂的网络，并不一定能顺利能正常的数据传输  
所以 TCP ==针对数据包丢失的情况，会用**重传机制**解决==  
接下来说说常见的重传机制：
- 超时重传
- 快速重传
- SACK
- D-SACK
## 超时重传
TCP 会在以下两种情况发生超时重传：
- 数据包丢失
- 确认应答丢失

`RTT` 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是==包的往返时间==  
超时重传时间是以 ==`RTO` （Retransmission Timeout 超时重传时间）==表示  
- 当超时时间 **RTO 较大**时，网络的空隙时间增大，降低了网络传输效率
- 当超时时间 **RTO 较小**时，RTO < RTT，会有不必要的重传，导致网络负荷增大  

==**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**==
**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍**  

> [!question] 超时触发重传存在的问题是，超时周期可能相对较长  
> 于是就可以用「快速重传」机制来解决超时重发的时间等待

## 快速重传（Fast Retransmit）
==它**不以时间为驱动，而是以数据驱动重传**==  
![[10.webp|450]]  
返回ACK=2的确认，知道Seq2还没有收到   
快速重传机制只解决了一个问题，就是超时时间的问题  

> [!question] 面临着另外一个问题
> 就是**重传的时候，是重传一个，还是重传所有的问题**  
> 为了解决不知道该重传哪些 TCP 报文，于是就有 `SACK` 方法

## SACK方法（Selective Acknowledgement）
在TCP头部【选项】字段中加一个 `SACK`，可以将已收到的数据信息发送给【发送方】  
==只需要重传丢失的数据==  

## Duplicate SACK
主要**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**  
D-SACK作用：
1. ==确认ACK丢包==，发送方确认发送数据没有丢失，是应答报文丢失了
2. ==确认因为网络延时的数据包==（ACK发送希望接受的下一个数据包的序列号，SACK发送已经接受到的数据信息）

D-SACK的好处：
1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了


---
# 滑动窗口
TCP是每发送一个数据，就要进行一次确认应答，像即时聊天  
这样的传输方式有一个缺点：==数据包的**往返时间越长，通信的效率就越低**==  
窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**  
即使滑窗内某个应答报文丢失，也没关系，只要最后一个确认应答即可，这意味着在这之前的数据都被接受到了，这叫==累计确认/累计应答==  
TCP头部字段`Window`窗口大小，接受端告诉发送端自己还有多少缓冲区可以接受数据  
所以，==通常窗口的大小是由接收方的窗口大小来决定的==  

## 发送方的四个部分
![[19.webp]]
- `SND.WND`：表示发送窗口的大小（大小是由接收方指定的）；
- `SND.UNA`（_Send Unacknoleged_）：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。 
- `SND.NXT`：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 `SND.UNA` 指针加上 `SND.WND` 大小的偏移量，就可以指向 #4 的第一个字节了

**可用窗口大小 = SND.WND -（SND.NXT - SND.UNA）**  

## 接收方的滑动窗口

![[20.webp]]
- `RCV.WND`：表示接收窗口的大小，它会通告给发送方。
- `RCV.NXT`：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量，就可以指向 #4 的第一个字节了

## 接收窗口和发送窗口的大小是相等的吗？
接收窗口的大小 $\approx$ 发送窗口的大小  
当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么==这个传输过程是存在时延的==


---
# 流量控制
**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量**



---
# 拥塞控制
> [!example]
> **在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**

==流量控制是避免【发送方】的数据填满【接收方】的缓存，并不知道网络中发生了什么  
拥塞控制是避免【发送方】的数据填满整个网络==  
==**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**==  
发送窗口`swnd`$\approx$接受窗口`rwnd`，加入拥塞窗口后，发送窗口`swnd`= min(cwnd,rwnd)，拥塞窗口的接受窗口的最小值  

拥塞窗口 `cwnd` 变化的规则：
- 只要网络中没有出现拥塞，`cwnd` 就会增大
- 但网络中出现了拥塞，`cwnd` 就减少

==【发送方】没有在规定的时间内接受到ACK应答报文，发生了超时重传，就会认为网络出现拥塞==  

## 拥塞控制算法
拥塞控制主要是四个算法：
- 慢启动
- 拥塞避免
- 拥塞发生
- 快速恢复
### 慢启动
==**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1**==  
![[27.webp|625]]

==可以看出慢启动算法，发包的个数是**指数性的增长**==  
==这种指数增长的方式能够快速探索和利用网络的带宽，提高数据传输的速率==  

有一个叫慢启动门限 `ssthresh` （slow start threshold）状态变量  
一般来说 `ssthresh` 的大小是 `65535` 字节  
- 当 `cwnd` < `ssthresh` 时，使用「慢启动算法」
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」

### 拥塞避免算法
==**每当收到一个 ACK 时，cwnd 增加 1/cwnd**==  
![[28.webp|500]]
==可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长==  
==这种谨慎的增长方式，能够避免过快增加导致的网络拥塞，同时逐步提高传输速率==  

就这么一直增长着后，网络就会==慢慢进入了拥塞的状况了，于是就会出现丢包现象==，这时就需要对丢失的数据包进行重传  
触发重传机制，也就进入了「拥塞发生算法」  

### 拥塞发生
当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
- 超时重传
- 快速重传

#### 超时重传
`ssthresh` 和 `cwnd` 的值会发生变化:
- `ssthresh` = `cwnd / 2`
- `cwnd` = 初始值


![[29.webp]]

但是这样重新开始慢启动会导致网络卡顿，因为慢启动是会突然减少数据流的  

#### 快速重传
`sstthresh` 和 `cwnd` 的值会发生变化:
- `cwnd = cwnd / 2`
- `ssthresh` = `cwnd`
- 进入快速恢复算法

### 快速恢复
快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 `RTO` 超时那么强烈  
快速恢复算法：
- `cwnd = ssthresh + 3`（3意思是确认有3个数据包被接受到了）
- 重传丢失的数据包
- 如果再收到重复的 ACK，那么 cwnd 增加 1
- 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，==该恢复过程已经结束==，可以回到恢复之前的状态了，也即再次进入拥塞避免状态

![[拥塞发生-快速重传.drawio.webp]]

==快速恢复算法进一步优化了拥塞窗口的调整过程，使得在丢包后，拥塞窗口能够更快地恢复到较高的传输速率==  

#### 为什么cwnd设置回了ssthresh
1. **快速恢复是拥塞发生后慢启动的优化，其首要目的仍然是降低 cwnd 来减缓拥塞，所以必然会出现 cwnd 从大到小的改变**
2. **过程2（cwnd逐渐加1）的存在是为了：发送方可以在不中断数据流的情况下，尽快将丢失的数据包发给目标，从而解决拥塞的根本问题**
