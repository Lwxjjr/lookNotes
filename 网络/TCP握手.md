# TCP头格式
![[format,png-20230309230534096.webp]]
- 序列号：建立连接随机生成，SYN包传给接受端主机，每传一次就加一【数据字节数】大小，==解决网络包乱序的问题==
- 确认应答号：下一次【期待】收到的序列号，==解决丢包问题==
- 控制号：
	- ACK（Acknowledgment）：为1表示【确认应答】有效
	- RST（Reset）：为1表示TCP连接异常必须强制断开连接
	- SYN（Synchronize）：为1表示希望建立连接
	- FIN（Finish）：为1表示不会再有数据发送，希望断开连接

---
# 为什么需要TCP
因为IP层是【不可靠】的，如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 `TCP` 协议来负责  
TCP是工作在【传输层】的可靠数据传输服务

---
# 什么是TCP？
TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议
- 面向连接：数据传输前需要建立连接，一对一
- 可靠的：TCP 都可以保证一个报文一定能够到达接收端
- 基于字节流：
	1. 数据被视为无结构的、连续的字节流
	2. 按照顺序传输
	3. 接收方会根据数据的到达顺序重组原始的数据流

> [!info] Linux通过 `netstat -napt` 查看TCP连接状态

![[10 1.webp]]

---
# 如何确定一个TCP连接？
四元组确定一个连接：
1. 源地址
2. 源端口
3. 目的地址
4. 目的端口

源地址/目的地址字段在IP头部，作用：通过IP协议发送报文给对方主机  
源端口/目的端口字段在TCP头部，作用：告诉TCP协议应该把报文发给哪个进程  

![[format,png-20230309230436594.webp]]

---
# TCP/UDP区别
1. ==连接==
	- TCP 是面向连接的传输层协议，传输数据前先要建立连接
	- UDP 是不需要连接，即刻传输数据
2. ==服务对象==
	- TCP 是一对一的两点服务，即一条连接只有两个端点。
	- UDP 支持一对一、一对多、多对多的交互通信
3. ==可靠性==
	- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。
	- UDP 是尽最大努力交付，不保证可靠交付数据
4. ==拥塞控制，流量控制==
	- TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
	- UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率
5. ==首部开销==
	- TCP 首部长度较长，会有一定的开销
	- UDP 首部只有 8 个字节，并且是固定不变的，开销较小
6. ==传输方式==
	- TCP 是流式传输，没有边界，但保证顺序和可靠。
	- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序
7. 分片不同
	- TCP的数据大小 > MSS，传输层分片，丢失分片，只需要传输丢失的分片
	- UDP的数据大小 > MTU，IP层分片

## TCP/UDP应用场景
由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：
- `FTP` 文件传输；
- HTTP / HTTPS；

由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：
- 包总量较少的通信，如 `DNS` 、`SNMP` 等；
- 视频、音频等多媒体通信；
- 广播通信；

![[Pasted image 20251029214705.png]]
## TCP有【首部字段】，UDP怎么没有
原因是 TCP 有==**可变长**的「选项」字段==，而 UDP 头部长度则是**不会变化**的，无需多一个字段去记录 UDP 的首部长度

## UDP头部有【包长度】，TCP怎么没有
TCP计算负载数据长度：
![[format,png-20230309230445811.webp]]
 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的  
 TCP 首部长度，则是在 TCP 首部格式已知的  
 TCP数据长度就可以计算出来

---
 
# TCP建立连接（三次握手）
三次握手过程：
![[TCP三次握手.drawio.webp|600]]

> [!info] 缩写
> isn：initial sequence number、
> RCVD: Received
1. 一开始，客户端和服务端都处于 `CLOSE` 状态  
2. 服务端主动监听某个端口，处于 `LISTEN` 状态
3. 客户端会随机初始化序号（client_isn），SYN置1，之后客户端处于 `SYN-SENT` 状态
4. 服务端收到客户端的 `SYN` 报文后，服务端随机初始化序号（server_isn），SYN，ACK置1，把该报文发给客户端，服务端处于 `SYN-RCVD` 状态
5. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文

==**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**==  

---
## 三次握手必要性：
### 什么是TCP连接？
==**用于保证可靠性和流量控制维护的某些状态信息**==，这些信息的组合，包括 Socket、序列号和窗口大小称为连接
![[format,png-20230309230428466.webp]]
所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。
- **Socket**：由 IP 地址和端口号组成
- **序列号**：用来解决乱序问题等
- **窗口大小**：用来做流量控制

==重要的是**为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接**==
三个方面分析三次握手的原因：
- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费
### 避免历史连接
> [!tip] RFC 793指出的TCP连接使用三次握手的首要原因
> _The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion._
> 
> **首要原因是为了防止旧的重复连接初始化造成混乱**  
> 考虑场景：客户端先发送 SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100）报文==（_注意！不是重传 SYN，重传的 SYN 的序列号是一样的_）==

1. 旧报文比新报文早到达服务端，此时服务端返回ACK + SYN报文给客户端，报文确认号是 90 + 1
2. 客户端收到后，发现自己期望收到的确认号是 100 + 1，返回 RST 报文
3. 服务端收到 RST 报文后，就会释放连接
4. 后续最新的 SYN 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了

> [!warning] 两次握手无法阻止历史连接
> 主要是两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一次历史连接，造成资源浪费
> 两次握手下，服务端在收到 SYN 报文后，就进入了 ESTABLISHED 状态，这意味着可以发送信息，但是如果是历史连接，客户端就会发送 Reset 报文，服务端只有在接收到 Reset 报文，才会知道这是一个历史连接，需要断开服务

### 同步双方初始化序列号
- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）

一来一回，才能==确保双方的初始序列号能被可靠的同步==
四次可以优化成三次，两次只能保证一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收

### 避免资源浪费
如果客户端发送的 `SYN` 报文在网络中阻塞了，重复发送多次 `SYN` 报文，那么服务端在收到请求后就会==**建立多个冗余的无效链接，造成不必要的资源浪费**==

### 总结：
三次握手可以：
1. 防止历史连接的建立
2. 减少双方不必要的资源开销
3. 帮助双方同步初始化序列号（保证数据包不重复，不丢失，按序传输）

不使用两次握手、四次握手的原因：
1. 两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号
2. 四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数


---
## 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？

- 为了防止历史报文被下一个相同四元组的连接接收（主要方面）
- 为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收

---
## 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
> [!info] 
> MSS（Maximum Segment Size）：单个TCP段的最大负载
> MTU（Maximum Trasmission Unit）：最大传输单元
> > [!tip] IP MTU <= 以太网 MTU，MTU大多数指的是第二层MTU

![[format,png-20230309230633447.webp]]

> [!warning] 如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传，毕竟IP协议本身是不可靠传输协议
> > [!example] 确认MSS本身就是为了让IP层不再分片，但是数据包依旧可能遇到链路上的设备接口低于MTU 1500的路由，此时就需要对IP数据包进行分片。此时如果某个分片的数据包丢失了，负责重传的是TCP或者4层以上进行

==IP层本身没有超时重传机制，是由传输层的TCP来负责超时和重传==
当某个IP分片丢失，接收方的IP层就无法组装成一个完整的TCP报文，也无法将数据报文送到TCP层，所以接收方不会响应ACK给发送方，因为发送方迟迟收不到 ACK 确认报文，所以会触发超时重传，就会重发「整个 TCP 报文（头部 + 数据）」
> [!info] 而上层的传输层并不知道下层的网络层被二次分片了，它知道丢包了就要重传，在它眼里的一个包自然不是分片后的包

让我们来看一下 IPv4 的数据包：
![[Pasted image 20250530205803.png|300]]
- 标识：为分片们进行标记，方便重组这些分片
- 标志：
	- MF（More Fragment）：为 `1` 时，告诉后续还有分片
	- DF（Don't
- 片偏移：在重组时需要靠这个进行排序

如果路由设备收到中间的一个分片，它可以通过`MF`来判断后面是否存在分片，但是它无法知道后面还有几个分片，而路由设备的缓冲区是有限的，==分片太多很可能会因为缓存区的限制导致部分分片被丢弃==
![[Pasted image 20250530210652.png|450]]
> [!info] MSS Clamping
> 处于3层的路由设备的职责是更快更高效地传输数据包，分片会增加路由设备的算了和内存的负担，为了避免分片，很多路由设备会有一种叫 MSS Clamping 的功能
> 路由设备在看到TCP SYN或者SYN/ACK包的时候，会对比 链路MTU 和 包MSS
> 如果 链路MTU < 包MSS
> 就会降低MSS的值以适应链路MTU
> >[!tip] 链路MTU由PMTUD：Path MTU Discovery（路径最大传输单元发现）确定
> >如果设定DF，链路上的设备碰到MTU的数据包不会进行分片处理，而是直接丢弃这个包，并返回消息告知发送方需要进行分片，发送方试探降低，知道发现MTU的最小值
> > >[!example] IPv6只允许发送源对数据包进行切分，不允许链路上的设备切分，此时就不需要额外的标志位

**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，经过 TCP 层分片后，如果一个 TCP 分片丢失后，==**进行重发时也是以 MSS 为单位**==，而不用重传所有的分片，大大增加了重传的效率

数据会被以`MSS`的长度为单位进行拆分，拆分出来的每一块数据都会被放入单独的网络包中

![[12 1.webp]]
> [!info] TCP报文的数据部分存放HTTP头部 + 数据，组装好TCP报文后，交给下面的网络层处理

---
## 握手丢失发生什么？
### 第一次握手丢失
客户端迟迟收不到服务端的SYN-ACK报文，触发【超时重传】机制（RTO），重传 SYN 报文，而且==**重传的 SYN 报文的序列号都是一样的**==  
每次超时重传的时间是上一次超时重传的2倍  
> [!info] Linux中，客户端的`SYN`报文最大重传次数由 `tcp_syn_retries`确定 
### 第二次握手丢失
> [!tip] 第二次握手的`SYN-ACK`报文目的：
> 1. `ACK`是对第一次握手的确认报文
> 2. `SYN`是服务端发起建立TCP连接的请求

客户端迟迟收不到服务端的SYN-ACK报文，会认为自己的SYN报文丢失了，触发【超时重传】机制（RTO）
服务端收不到客户端的ACK报文，服务端会触发【超时重传】机制（RTO） 
> [!info] `Linux`中，`SYN-ACK`报文重传次数由`tcp_synack_retries`决定，默认为5
### 第三次握手丢失
如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数  
注意，==**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**==  

---
## SYN攻击
服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务

![[format,png-20230309230625853.webp]]  

- SYN队列：半连接队列
- Accpet队列：全连接队列

![[format,png-20230309230622886.webp]]不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文  
SYN 攻击方式最直接的表现就会把 TCP 半连接队列打满，这样**当 TCP 半连接队列满了，后续再在收到 SYN 报文就会丢弃**，导致客户端无法和服务端建立连接   

避免 SYN 攻击方式，可以有以下四种方法：
- 调大 netdev_max_backlog；
- 增大 TCP 半连接队列；
- 开启 tcp_syncookies；
- 减少 SYN+ACK 重传次数

---
# TCP连接断开（四次挥手）
双方都可以主动断开连接，断开连接后主机中的「资源」将被释放  

![[format,png-20230309230614791.webp|550]]

1. 客户端打算关闭，发送一个TCP首部FIN标志位置为1的报文，进入 `FIN_WAIT_1` 的状态
2. 服务端收到报文后，就向客户端发送ACK应答报文，服务端进入 `CLOSE_WAIT` 状态
3. 客户端收到 `ACK` 应答报文后进入 `FIN_WAIT_2` 状态
4. 等待服务端处理完数据后，向客户端发送FIN报文，服务端进入 `LAST_ACK` 状态
5. 客户端收到 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
6. 服务端收到 `ACK` 应答报文就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭
7. 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭

==**主动关闭连接的，才有 TIME_WAIT 状态**==

![[18635e15653a4affbdab2c9bf72d599e.webp]]

- 客户端主动调用关闭连接的函数，于是就会发送 FIN 报文，这个 FIN 报文代表客户端不会再发送数据了，进入 FIN_WAIT_1 状态；
- 服务端收到了 FIN 报文，然后马上回复一个 ACK 确认报文，此时服务端进入 CLOSE_WAIT 状态。在收到 FIN 报文的时候，TCP 协议栈会为 FIN 包插入一个文件结束符 EOF 到接收缓冲区中，服务端应用程序可以通过 read 调用来感知这个 FIN 包，这个 EOF 会被**放在已排队等候的其他已接收的数据之后**，所以必须要得继续 read 接收缓冲区已接收的数据；
- 接着，当服务端在 read 数据的时候，最后自然就会读到 EOF，接着 **read() 就会返回 0，这时服务端应用程序如果有数据要发送的话，就发完数据后才调用关闭连接的函数，如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数**，这时服务端就会发一个 FIN 包，这个 FIN 报文代表服务端不会再发送数据了，之后处于 LAST_ACK 状态；
- 客户端接收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入 TIME_WAIT 状态；
- 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；
- 客户端经过 2MSL 时间之后，也进入 CLOSE 状态；

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**

---
## 四次挥手必要性
> [!info] TCP是全双工通信，可以双向传输数据。任意一方可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接

- 关闭连接时，客户端向服务端发送 `FIN` 时，==仅仅表示客户端不再发送数据了但是还能接收数据==
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而==服务端可能还有数据需要处理和发送==，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接
---
## 三次挥手
但是**在特定情况下，四次挥手是可以变成三次挥手的**  
当被动关闭方【没有数据要发送】且【开启了TCP延迟确认机制】，就会合并2，3次挥手  

![[d7b349efa4f94453943b433b704a4ca8.webp]]
TCP 延迟确认机制是默认开启的，所以导致我们抓包时，看见三次挥手的次数比四次挥手还多  
### TCP延迟确认机制
当发送没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文  
==为了解决 ACK 传输效率低问题，所以就衍生出了 **TCP 延迟确认**==
- 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
- 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
- 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK

![[33f3d2d54a924b0a80f565038327e0e4.webp|600]]

延迟等待的时间是在 Linux 内核中定义的
![[ae241915337a4d2c9cb2f7ab91e6661d.webp]]

如果要关闭 TCP 延迟确认机制，可以在 Socket 设置里启用 TCP_QUICKACK

---
## 挥手丢失会发生什么？

---

## 为什么TIME_WAIT的等待时间是2MSL?
==MSL：Maximum Segment Lifetime（**报文最大生存时间**）==  
MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡   
TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**  
==可以看到 **2MSL时长** 这其实是相当于**至少允许报文丢失一次**==
`2MSL`的时间是从客户端收到FIN后发送ACK开始计时的


## 为什么需要TIME_WAIT状态
主动发起关闭连接的一方，才会有 `TIME-WAIT` 状态
需要 TIME-WAIT 状态，主要是两个原因：
- 防止历史连接中的数据，被后面相同四元组的连接错误的接收
- 保证「被动关闭连接」的一方，能被正确的关闭

TIME-WAIT 作用是**等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭**  

---
# TLS四次握手
HTTPS 建立连接的过程，先进行 TCP 三次握手，再进行 TLS 四次握手  
==TLS与TCP三次握手可以同时进行，条件==：
1. **客户端和服务端都开启了 TCP Fast Open 功能，且 TLS 版本是 1.3**
2. **客户端和服务端已经完成过一次通信** 

## TCP Fast Open（TFO）
常规先要经过 TCP 三次握手后，建立完可靠的 TCP 连接后，客户端才能将数据发送给服务端，==TCP Fast Open 是为了绕过 TCP 三次握手发送数据==，在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延  
==**想要绕过 TCP 三次握手发送数据，得建立第二次以后的通信过程**==  

首次建立连接：
- 客户端SYN报文中包含 Fast Open 选项，且该选项的 Cookie 为空，表示客户端请求 Fast Open Cookie
- 支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 报文中的 Fast Open 选项以发回客户端
- 客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie
![[7cb0bd3cde30493fec9562cbdb549f83.webp]]

对于客户端与服务端的后续通信，客户端可以在第一次握手的时候携带应用数据，从而达到绕过三次握手发送数据的效果

![[fc452688b9351e0cabf60212dde3f21e.webp]]
## TLSv1.3
TLSv1.3 握手过程只需 1-RTT 的时间
![[1fd5ba4000f82613fdd70cab6da4b9cb.webp]]

TLSv1.3 还有个更厉害到地方在于**会话恢复**机制，在**重连 TLvS1.3 只需要 0-RTT**
![[59539201f006d7dc0a06333617e5ea85.webp]]

在前面我们知道，客户端和服务端同时支持 TCP Fast Open 功能的情况下，**在第二次以后到通信过程中，客户端可以绕过三次握手直接发送数据，而且服务端也不需要等收到第三次握手后才发送数据**  
**「TCP Fast Open + TLSv1.3」情况下，在第二次以后的通信过程中，TLS 和 TCP 的握手过程是可以同时进行的**