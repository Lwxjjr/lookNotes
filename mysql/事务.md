# ACID原则
事务是一组原子性的操作，是**数据库并发控制的基本单位**
实现事务必须要遵守 4 个特性:
1. **原子性（Atomicity）**：==一个事务中的所有操作，要么全部完成，要么全部不完成==，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态
2. **一致性（Consistency）**：是指==事务操作前和操作后，数据满足**完整性约束**==，数据库保持一致性状态
3. **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，==隔离性可以防止多个事务并发执行时**由于交叉执行而导致数据的不一致**==，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的
4. **持久性（Durability）**：==事务处理结束后，对数据的修改就是永久的==，即便系统故障也不会丢失
---
### InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？
- 原子性是通过 **undo log（回滚日志）** 来保证的；
- 隔离性是通过 **MVCC（多版本并发控制）** 或 **锁机制** 来保证的；
- 持久性是通过 **redo log （重做日志）** 来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；

---
# 并行事务会引发什么问题
为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题  
因为 MySQL 服务端是允许多个客户端连接的，这意味 MySQL 会出现同时处理多个事务的情况，就可能出现：
1. **脏读（dirty read）**
2. **不可重复读（non-repeatable read）**
3. **幻读（phantom read**

## 脏读
==**一个事务「读到」了另一个「未提交事务修改过的数据」**== 
==未提交的事务有可能发生回滚操作，那么读取的数据就是过期的数据==

![[10b513008ea35ee880c592a88adcb12f.webp]]

## 不可重复读（内容不一致）
==**在一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况**==  

![[f5b4f8f0c0adcf044b34c1f300a95abf.webp]]

## 幻读（数量不一致）
一个事务内多次查询某个符合查询条件的「记录数量」，==**如果出现前后两次查询到的记录数量不一样的情况**==  

![[d19a1019dc35dfe8cfe7fbff8cd97e31.webp]]

---
# 事务的隔离级别
多个事务并发执行引发的问题：
- 脏读：读到其他事务未提交的数据；
- 不可重复读：前后读取的数据不一致；
- 幻读：前后读取的记录数量不一致

![[d37bfa1678eb71ae7e33dc8f211d1ec1.webp]]
SQL标准提出了四种隔离级别来规避这些现象：
- **读未提交（_read uncommitted_）**，指一个==事务还没提交时==，它做的变更就能被其他事务看到
- **读提交（_read committed_）**，指一个==事务提交之后==，它做的变更才能被其他事务看到
- **可重复读（_repeatable read_）**，指一个事务执行过程中看到的数据，一直跟==这个事务启动时看到的数据是一致的==，**MySQL InnoDB 引擎的默认隔离级别**
- **串行化（_serializable_ ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行

隔离水平高低排序：
![[cce766a69dea725cd8f19b90db2d0430.webp]]

针对不同的隔离级别，并发事务时可能发生的现象也会不同：
![[4e98ea2e60923b969790898565b4d643.webp]]


==**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象**==  
解读方案：
- ==针对快照读（普通 Select 语句）==，是**通过 ==MVCC== 方式解决了幻读**
- ==针对当前读（Select ... for update 语句）==，是**通过 ==next-key lock==（记录锁+间隙锁）方式解决了幻读**

| 机制       | 主要目标              | 核心思想      | 解决的冲突     |
| -------- | ----------------- | --------- | --------- |
| **行级锁**  | 保证**写操作**的原子性和隔离性 | **阻塞/等待** | **写-写冲突** |
| **MVCC** | 提高**读操作**的并发性能    | **版本/快照** | **读-写冲突** |
## 这四种隔离级别具体是如何实现的

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 **Read View 来实现的，它们的区别在于==创建 Read View 的时机不同==，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。**「读提交」隔离级别是在==「每个语句执行前」==都会重新生成一个 Read View，而「可重复读」隔离级别是==「启动事务时」==生成一个 Read View，然后整个事务期间都在用这个 Read View

# Read View 在 MVCC 里如何工作的？
我们需要了解两个知识：
- Read View 中四个字段作用
- 聚簇索引记录中两个跟事务有关的隐藏列
## Read View

![[readview结构.drawio.webp]]
==**活跃事务：启动了还没提交的事务**==  
以下四个字段都是在==创建 Read View 时==  
**Read View 四个重要字段**：
- m_ids：当前数据库中【活跃事务】的==事务id列表==
- min_trx_id：当前数据库中【活跃事务】的==事务id最小的事务==
- max_trx_id: 当前数据库应该给下一个事务的id，即全==局事务最大id 值 + 1==
- creator_trx_id：==创建的 Read View 的事务id==

在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：
![[ReadView.drawio.webp|550]]

- trx_id < min_trx_id：对当前事务可见（创建 Read View 前已经提交的事务）
- trx_id >= max_trx_id：对当前四五不可见（创建 Read View 后才启动的事务）
- min_trx—_id < trx_id < max_trx_id:
	- trx_id 在 m_ids 列表中，可见
	- trx_id 不在 m_ids 列表中，不可见

==**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）**==
**MVCC 就是通过保存数据的多个历史版本，让每个事务都能看到一个属于自己的、一致的数据快照，从而实现读写操作互不阻塞。**
## 聚簇索引记录中的两个隐藏列
![[f595d13450878acd04affa82731f76c5.webp|600]]

对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：
- trx_id： ==改动聚簇索引记录的事务id==
- roll_pointer: 改动聚簇索引记录时，会把旧版本的记录写入到 undo 日志中，这个指针指向旧版本的记录

---
# 发生幻读的情况
1. 事务 A 对 id = 5 这条记录进行了更新操作，在这个时刻，这条新记录的 trx_id 隐藏列的值就变成了事务 A 的事务 id，之后事务 A 再使用普通 select 语句去查询这条记录时就可以看到这条记录了

![[幻读发生.drawio.webp]]

2. 快照 + 当前读
	1. T1时刻：事务A执行快照读：select * from t_test where id > 100 得到了 3 条记录
	2. T2 时刻：事务 B 往插入一个 id= 200 的记录并提交
	3. T3 时刻：事务 A 再执行「当前读语句」 select * from t_test where id > 100 for update 就会得到 4 条记录，此时也发生了幻读现象

要避免这类特殊场景下发生幻读的现象的话，==**就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句**==，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录  