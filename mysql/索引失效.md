可以在 `EXPLAIN` 的 `Result` 中查看 `key` 确定使用了什么索引 
### 1. 左/左右模糊匹配（like %xx 或 like %xx%）
```SQL
select * from t_user where name like '林%';
```
==**因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较**==

---
### 2. 索引函数
```SQL
select * from t_user where length(name)=6;
```
==因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了==
不过，从 ==MySQL 8.0 开始，索引特性增加了函数索引==:  
针对函数计算后的值建立一个索引
```SQL
alter table t_user add key idx_name_length ((length(name)));
```

---
### 3. 左侧表达式计算
```SQL
explain select * from t_user where id + 1 = 10;
```
==因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引==

---
### 4. 隐式类型转换（string -> int 再比较)

**MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**

![[e7aa91ce5e699ff0c6c357f6b1e70597.webp|500]]
```SQL
select * from t_user where phone = 1300000001;
```

---

### 5. 联合索引非最左匹配（所以合理建立索引才能保证命中率）
### 6. OR 两侧不都是索引