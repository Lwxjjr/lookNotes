# 索引的数据结构
MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的  
==磁盘读写的最小单位是**扇区**==，扇区的大小只有 `512B` 大小  
操作系统一次会读写多个扇区，所以==**操作系统的最小读写单位是块（Block）**==  
**Linux 中的块大小为 `4KB`**，也就是一次磁盘 I/O 操作会直接读写 8 个扇区  
要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：
- ==能在尽可能少的磁盘的 I/O 操作中完成查询工作==
- 要能高效地查询某一个记录，也要能高效地执行范围查找

---
# 选择
**索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数**  
## 树索引结构的选择
### 1. 不使用二叉树
插入数据可能变成斜树，查询相当于链表，做一次全表扫描
### 2. 自平衡
**红黑树性质**:  
==**从根到叶子的最长的可能路径不多于最短的可能路径的两倍长**==
> [!红黑树性质]
>（1）每个节点或者是黑色，或者是红色。  
>（2）根节点是黑色。  
>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]  
>（4）如果一个节点是红色的，则它的子节点必须是黑色的。  （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

**平衡二叉树的性质：**
> [!平衡二叉树性质]
> 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树

**平衡二叉树和红黑树区别：**
1. 红黑树追求大致平衡，保证==每次插入最多只需要三次旋转==就能达到平衡，实现起来也更为简单
2. 平衡二叉树追求绝对平衡，==每次插入新节点之后需要旋转的次数不能预知==，实现起来比较麻烦

==**不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率**==
### 3. B树
B-树是一种**多路自平衡的搜索树**，允许每个节点有更多的子节点  
1. B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」
2. 如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降

### 4. B+树
**数据库B+Tree对于B-Tree优化思路有：**
1. 非叶子节点data，只存储索引，可以放更多的索引。
2. 所有叶子节点之间都有一个链指针（顺序访问指针，可以提高访问的性能）。
3. 数据记录都存放在叶子节点中，查询性能稳定，B树查找最坏情况下到叶子节点

![[Pasted image 20250421102836.png|550]]

![[Pasted image 20250421103133.png]]

> [!解释]
> 这里解释一下为什么我们看到的标准的B+树中，叶节点之间连接的是单向指针，而在有些地方看到双向指针，这是因为InnoDB存储引擎在使用B+树作为索引存储结构时进行的改造，方便索引到叶节点之后进行范围查找，直接通过指针就可以找到上/下一页的地址。

通常在B+Tree上有两个头指针:
1. ==指向根节点==
2. ==指向关键字最小的叶子节点==

因此可以对B+Tree进行两种查找运算
1. 主键的范围查找和分页查找
2. 从根节点开始，进行随机查找

#### 相比B树的优点
##### 1. 单点查询
**B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更
「矮胖」，查询底层节点的磁盘 I/O次数会更少**
##### 2. 插入和删除效率
B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除  
B 树没有冗余节点，删除节点的时候涉及复杂的树变形
##### 3、范围查询
 **B+ 树所有叶子节点间有一个链表进行连接，有益于范围查找**

## Hash结构索引
**原理**： 哈希索引用索引列的值计算该值的hashCode（hash方法），然后在hashCode相应的位置存执该值所在行数据的物理位置（指针），然后去哈希表中去找  
**特点**：
1. 哈希索引只包含哈希码和指针，不存储数据字段值。  
2. 哈希索引数据并不是按循序存储的，因此无法用于排序。  
3. 因为要通过查询值计算确定的哈希码，所以哈希索引不支持部分匹配，不支持范围查找，只支持等值比较查询  
4. 当哈希冲突很多的时候，效率会降低



