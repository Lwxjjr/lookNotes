# 锁分类
![[1e37f6994ef44714aba03b8046b1ace2.webp]]

---
# 全局锁
### 使用全局锁：
使用全局锁命令：
```SQL
flush tables with read lock
```
执行后，==**整个数据库就处于只读状态了**==，这时其他线程执行以下操作，都会被阻塞  

释放全局锁命令：
```SQL
unlock tables
```
当然，当会话断开了，全局锁会被自动释放

### 全局锁应用场景
全局锁主要应用于做==**全库逻辑备份**==

### 全局锁缺点
加上全局锁，意味着整个数据库都是只读状态。
那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成==业务停滞==

### 改进
如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作

---
# 表级锁
MySQL 里面表级别的锁有这几种：
- 表锁；
- 元数据锁（MDL）;
- 意向锁；
- AUTO-INC 锁；
### 1. 表锁
如想对学生表（t_student）加表锁：
```sql
// 表级别的共享锁（读锁）
// 允许当前会话读取被锁定的锁，阻止其他会话对这些表进行写操作
lock tables t_student read;

// 表级别的独占锁（写锁）
// 允许当前会话对表读写，阻止其他会话对这些表进行读/写操作
lock tables t_stuent write;
```
==表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作==  

要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：
```sql
unlock tables
```
在没有出现颗粒度更细的锁的时候，表锁是最常用的处理并发的方式

### 2. 元数据锁（MDL）
我们不需要显示的使用`MDL`
我们对数据库表进行操作，会自动给这个表加上MDL
==`MDL`是为了保证当用户对表执行 `CRUD` 操作时，防止其他线程对这个表结构做了变更==
- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**

==`MDL`是在事务提交后才会释放，在事务执行期间，`MDL`是一直持有的==
申请`MDL`锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现`MDL`写锁等待，会阻塞后续该表的所有`CRUD`操作

> [!example]
> A：开启事务，执行select语句，对该表加上`MDL`读锁
> B：执行select语句，对该表加上`MDL`读锁，不会阻塞，读读不冲突
> C: 修改表字段，由于A事务没有提交，`MDL`读锁还在占用，C即无法申请写锁，阻塞

### 3. 意向锁
==**意向锁的目的是为了快速判断表里是否有记录被加锁**==
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」

普通的`select`是不会加行级锁的，是利用`MVCC`实现一致性，是无锁的
`select`也是可以对记录加共享锁和独占锁的
```sql
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```
==意向共享锁、意向独占锁是表级锁==，不会和行级的共享锁和独占锁发生冲突，意向锁之间也不会发生冲突，只会和表锁发生冲突

### 4. AUTO-INC锁
主键通常是自增的，是通过主键字段声明`AUTO_INCREMENT`属性实现的
插入数据可以不指定主键值，数据库会自动给主键赋值传递的值，这是通过`AUTO-INC`锁实现
==`AUTO-INC`锁是特殊的表锁机制==
==**在插入数据时，会加一个表级别的 AUTO-INC 锁**==
不再是一个事务提交后才释放，而是在==执行完插入语句后就会立即释放==
`MYSQL5.1.22`开始，`InnoDB`存储引擎提供了一种==轻量级的锁来实现自增==
插入数据时，会被`AUTO_INCREMENT`修饰的字段加上轻量级锁，然后==**给该字段赋值一个自增的值，就把这个轻量级锁释放了**==，而不需要等待整个插入语句执行完才释放锁
`innodb_autoinc_lock_mode`系统变量：
- `0`：采用`AUTO-INC`锁，语句执行之后才释放锁
- `2`：采用轻量级锁，申请自增主键后就释放锁
- `1`：
	- 普通 insert 语句，自增锁在申请之后就马上释放
	- 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放

当 `innodb_autoinc_lock_mode = 2` 是性能最高的方式，但是当搭配 `binlog` 的日志格式是 `statement` 一起使用的时候，在「主从复制的场景」中会发生==**数据不一致的问题**==
==**当 innodb_autoinc_lock_mode = 2 时，并且 binlog_format = row，既能提升并发性，又不会出现数据一致性问题**==



---
# 行级锁
`InnoDB`引擎是支持行级锁的
`MyISAM`引擎不支持行级锁的
==锁定读==：
这2条语句必须在同一个事务中，==因为当事务提交了，锁就会被释放==
使用前要加上`begin、start transaction`或`set autocommit = 0`
```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```
共享锁（S锁）/独占锁（X锁）
![[x锁和s锁.webp]]

行级锁分类：
- `Record Lock`，记录锁，记录锁，把一条记录锁上
- `Gap Lock`，间隙锁，锁定范围，不包含记录本身
- `Next-Key Lock`：临键锁，`Record Lock + Gap Lock`，锁定范围，包含记录本身

### Record Lock
记录锁，锁住的是一条记录，记录锁也有`S`锁和`X`锁之分
```sql
mysql > begin;
mysql > select * from test where id = 1 for update;
```
给`test`表中主键为`1`的记录加上`X`型的记录锁

### Gap Lock
间隙锁，==只存在于可重复读的隔离级别==，目的解决幻读的现象
> [!example]
> 表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生

间隙锁的`X`/`S`锁没有什么区别，间隙锁之间是兼容的，==两个事务可以同时持有包含共同间隙范围的间隙锁，不存在互斥关系==
**间隙锁的意义只在于阻止区间被插入**
**所以一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁**

### Next-Key Lock
临键锁，`Record Lock + Gap Lock`
> [!Example]
> 表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录

`Next-Key Lock` 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中
==**如果一个事务获取了 X 型的 Next-Key Lock，那么另外一个事务在获取相同范围的 X 型的 Next-Key Lock 时，是会被阻塞的**==


### 插入意向锁（不是意向锁，是特殊的间隙锁）
一个事务插入一个记录前，需要判断插入位置是否已经被其他事务加入了`Gap Lock / Next-Key Lock`
有的话，插入操作就会发生阻塞，直到事务提交
==在此期间会生成一个插入意向锁：表明有事务想在某个区间插入新纪录，但是现在处于等待状态==
**不同于间隙锁的是，该锁只用于并发插入操作**
> [!example]
> 假设事务 `A` 已经对表加了一个范围 id 为（3，5）间隙锁
> 事务 `A` 还没提交，事务 `B` 向该表插入一条 `id = 4` 的新纪录，这时会判断到插入的位置已经被事务 `A` 加了间隙锁，于是事务 `B` 会生成一个插入意向锁，然后将锁的状态设置为等待状态，此时事务 `B` 发生阻塞，直到事务 `A` 提交了事务
> 



---
# MySQL行级锁加锁规则
加锁的对象是索引，加锁的基本单位是`Next-Key Lock`
在能==使用记录锁/间隙锁就能避免幻读现象的场景下==，`Next-Key Lock`就会退化成记录锁/间隙锁
> [!命令分析加锁]
> select * from performance_schema.data_locks\G
> 可以查看其中的 LOCK_TYPE 和 LOCK_MODE
> LOCK_TYPE: 确认锁的粒度
> LOCK_MODE: 
> - X：`Next-Key Lock`
> - X、REC_NOT_GAP：`Record Lock`
> - X、GAP：`GAP`

### 唯一索引等值查询
当我们用唯一索引进行等值查询的时候：
- 查询的记录是【存在】的，`Next-Key Lock`退化为`Record Lock`
- 查询的记录是【不存在】的，`Next-Key Lock`退化为`Gap Lock`

### 唯一索引范围查询
范围查询，会对每一个扫描到的索引加`Next-Key Lock`，遇到情况：
- 【大于等于】的范围查询，如果等值查询的记录在表中，退化为`Record Lock`
- 【小于/小于等于】的范围查询，要看条件值的记录是否在表中：
	- 不在，范围内的记录索引锁退化为`Gap Lock`
	- 在，【小于】退化为`Gap Lock`，【小于等于】依然是`Next-Key Lock`


---
# 死锁
可重复读隔离级别下，是存在幻读的问题
`Innodb` 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 `next-key` 锁
普通的 `select` 语句是不会对记录加锁的，因为它是通过 `MVCC` 机制实现的快照读
如果要在查询时对记录加行锁，要使用下面的 `2` 个方式：
```sql
begin;
//对读取的记录加共享锁
select ... lock in share mode;
commit; //锁释放

begin;
//对读取的记录加排他锁
select ... for update;
commit; //锁释放
```
==行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁==

死锁的四个必要条件：
- **互斥**，多个进程/线程不能同时共享同一资源
- **占有且等待**，一个进程已经持有了至少一个资源，同时请求另一个资源，而该资源被其他进程占用，进程在等待所需的资源时，仍然持有它已经拥有的资源
- **不可强占用**，操作系统不允许强制剥夺一个进程已持有的资源
- **循环等待**，多个进程之间形成了一个闭合的等待环

在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：
- **设置事务等待锁的超时时间**，`innodb_lock_wait_timeout` 是用来设置超时时间的，默认值时 50 秒
- **开启主动死锁检测**，主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行，`innodb_deadlock_detect` 设置为 on，表示开启这个逻辑，默认就开启


---
# update 没加索引会锁全表？
在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁
我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的
==**在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了**==
> [!example] 
> ```sql
> TA > begin;
> TB > begin;
> TA > update t_stu set score = 100 where name = "L";
> TA > update t_stu set score = 77 where id = 5;（阻塞）
> TA > commit; 
> TB > commit;

update 不带索引就是全表扫扫描，也就是表里的索引项都加锁，相当于锁了整张表，所以大家误以为加了表锁
==我们可以将 MySQL 里的 `sql_safe_updates` 参数设置为 1，开启安全更新模式==
update 语句必须满足如下条件之一才能执行成功：
- 使用 where，并且 where 条件中必须有索引列
- 使用 limit
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列

delete 语句必须满足以下条件能执行成功：
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列

