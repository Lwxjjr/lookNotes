# 什么是索引

索引就是数据的目录，它们都在存储引擎中

---
# 索引分类
分类的四个角度：
- 【数据结构】：**B+tree索引、Hash索引、Full-text索引**
- 【物理存储】：**聚簇索引（主键索引）、二级索引（辅助索引）**
- 【字段特性】：**主键索引、唯一索引、普通索引、前缀索引**
- 【字段个数】：**单列索引、联合索引**

## 按数据结构分类
![[索引分类.drawio.webp]]

## 按物理存储分类
索引分为聚簇索引（主键索引）、二级索引（辅助索引）  
这两个区别：
1. 主键索引的 B+Tree 的叶子节点存放的是实际数据  
2. 二级索引的 B+Tree 的叶子节点存放的是主键值

## 按字段特性分类
索引分为主键索引、唯一索引、普通索引、前缀索引  
- 主键索引：一张表最多一个，不允许空值（PRIMARY KEY)
- 唯一索引：一张表多个，允许空值（UNIQUE KEY）
- 普通索引：不要求字段为主键，也不要求为UNIQUE（INDEX）
- 前缀索引：取字段前缀

## 按字段个数分类
索引分为单列索引、联合索引（复合索引）  
联合索引eg：
```SQL
CREATE INDEX index_product_no_name ON product(product_no, name);
```
==利用联合索引的前提是索引里的 key 是有序的==  
范围查询的字段可以使用联合索引，但是在范围查询后面的字段无法使用联合索引  
```SQL
select * from t_table where a > 1 and b = 2
// 解释
EXPLAIN select * from t_table where a > 1 and b = 2
```
- 联合索引是按照a字段的值排序的，扫描直到 a <= 1
- 在 a > 1 的条件中，b字段的值是无序的

![[q1.webp]]
**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**

### 索引下推
- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， 可以在联合索引遍历过程中，==**对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**==。

EXPLAIN 中出现了 `Using index condition`，说明使用了索引下推  

---
# 什么时候（不）需要索引？
==索引最大的好处是提高查询速度==，但是索引也是有缺点的，比如：
- 需要==占用物理空间==，数量越大，占用空间越大；
- ==创建索引和维护索引要耗费时间==，这种时间随着数据量的增加而增大；
- ==动态维护 B+ 树==
## 适用索引
- 字段有唯一性，如商品编码
- 常使用 `WHERE` 查询条件的字段
- 常使用 `Group BY` 和 `ORDER BY` 的字段，查询时不需要再一次排序
## 不适用索引
- `WHERE、GROUP BY、ORDER BY` 用不到的字段，因为是起不到定位作用的字段
- 字段中存在大量重复数据，如性别
- 表数据太少的时候
- 经常更新的字段不用创建索引，如电商的用户余额

---
# 优化索引的方法
- 前缀索引优化（减少索引字段大小，适用大字符串的字段）
- ==覆盖索引优化==（query的所有字段在叶子节点都能找到，避免回表）
- ==主键索引最好是自增的==
	- 自增：插入新纪录，都是追加操作，不需要重新移动数据
	- 非自增：插入有可能插入到现有数据页的中间位置，需要移动其他数据满足新数据的插入，导致==页分裂==，页分裂可能会造成大量的内存碎片，导致索引结构不紧凑，影响查询效率
- ==主键字段的长度不要太大，可以减少二级索引暂用的空间大小==
- ==索引最好设置为 NOT NULL==
	- 索引存在 NULL 导致优化器处理更复杂
	- NULL 没有意义，但是占用物理空间，InnoDB行格式中至少会用1字节空间存储NULL值列表
- 防止索引失效