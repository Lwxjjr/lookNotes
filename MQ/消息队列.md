Do：引入消息队列视频
- 解耦
- 异步
- 削峰

# 应用解耦

![[Pasted image 20250507221523.png]]
- **没有引入消息队列**，如果库存库存系统异常无法访问，会导致下单失败；或者随着公司业务拓展，物流系统也需要接入下单信息，此时订单系统还需要增加调用物流系统的接口
- **引入消息队列**，用户下单后，将消息写入消息队列，返回下单成功；库存和物流系统通过订阅下单消息，获取下单信息，库存系统根据下单信息进行库存扣减操作，物流系统根据下单信息生成物流单；==即使此时库存系统无法访问，但是不会影响下单流程。当库存系统恢复后可以正常消费消息==

对mq的解耦能力：
- 拥有mq后，==producer 不需要过分关心 consumer 的身份信息==，只需要把消息按照指定的协议投递到对应的 topic 即可
-  producer 在处理请求时，==只需要把消息投递到 mq 即可认为流程处理结束==，相比于同步请求下游，整个流程会更加轻便灵活，拥有更高的吞吐量
- 因为有 mq 作为缓冲层. ==下游 consumer 可以设定好合适的消费限流参数==，按照指定的速率进行消费，能够在很大程度上对 consumer 起到保护作用
---
# 异步提速
![[Pasted image 20250507221801.png]]
- **没有引入消息队列**，用户从注册到响应成功，需要先保存注册信息，再发送邮件通知，邮件发送成功后再发送短息通知，短息发送成功后才响应给用户，用户体验不好  
- **引入消息队列**，保存用户信息后，短信通知和邮件通知消息写入MQ(此过程耗时比较短)。极大的缩短了响应时间。增强用户体验

---
# 流量削峰
![[Pasted image 20250507221938.png]]

---
# 消息重复消费怎么解决
生产端为了保证消息发送成功，可能会重复推送(直到收到成功ACK)，会产生重复消息
MQ Server框架会给生产端提供一个幂等性的发送消息接口
消费端在高并发要求中
1. 拉取消息+业务处理+提交消费位移需要做事务处理
2. 消费端服务可能宕机，很可能会拉取到重复消息

所以，只能业务端自己做控制，**对于已经消费成功的消息，本地数据库表或Redis缓存业务标识，每次处理前先进行校验，保证幂等**

# 消息丢失
![[1719381898719-af6c00bf-8760-4639-bd21-e6d422ef7779.webp]]
- **消息生产阶段**：生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理
- **消息存储阶段**：Kafka 在使用时是部署一个集群，这样写消息具有多个副本
- **消息消费阶段**：消费者接收消息+消息处理之后，才回复 ack 的话，那么消息阶段的消息不会丢失

